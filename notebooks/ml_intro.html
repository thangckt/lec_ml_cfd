
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Introduction to machine learning &#8212; Machine learning in computational fluid dynamics</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="shortcut icon" href="https://github.com/thangckt/note/blob/main/docs/1images/one-note-128-y.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Predicting the stability regime of rising bubbles" href="bubble_path_classification.html" />
    <link rel="prev" title="Finite-volume-based CFD in a nutshell" href="cfd_intro.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
      
      
      <h1 class="site-logo" id="site-title">Machine learning in computational fluid dynamics</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../README.html">
                    Machine learning in computational fluid dynamics
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Lectures
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="ml_cfd_intro.html">
   Course overview and motivation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cfd_intro.html">
   Finite-volume-based CFD in a nutshell
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Introduction to machine learning
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="bubble_path_classification.html">
   Predicting the stability regime of rising bubbles
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mass_transfer_regression.html">
   Computing highly accurate mass transfer at rising bubbles
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cylinder_pinn.html">
   Approximating the flow past a cylinder with limited data
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="coherent_structures_dim_reduction.html">
   Analyzing coherent structures in flows displaying transonic buffets
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cylinder_rom.html">
   Reduced-order modeling of the flow past a cylinder
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cylinder_bayesian_opt.html">
   Optimizing parameters for open-loop flow control
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cylinder_drl.html">
   Controlling the flow past a cylinder
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Exercises
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="python_intro.html">
   A brief introduction to Python programming
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="system_setup.html">
   Setting up your system
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cfd_intro_exercise.html">
   End-to-end simulations in OpenFOAM and Basilisk
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ml_intro_exercise.html">
   End-to-end ML project with OpenFOAM and PyTorch
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="bubble_path_classification_exercise.html">
   Predicting the stability regime of rising bubbles
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mass_transfer_regression_exercise.html">
   Computing highly accurate mass transfer at rising bubbles
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cylinder_pinn_exercise.html">
   Approximating the flow past a cylinder with limited data
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="coherent_structures_dim_reduction_exercise.html">
   Analyzing coherent structures in flows displaying transonic buffets
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cylinder_rom_exercise.html">
   Reduced-order modeling of the flow past a cylinder in flowTorch
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cylinder_bayesian_opt_exercise.html">
   Open-loop control of the flow past a cylinder
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cylinder_drl_exercise.html">
   Controlling the flow past a cylinder with OpenFOAM and PyTorch
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../_sources/notebooks/ml_intro.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#floating-point-numbers">
   Floating point numbers
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-ieee-754-standard-and-roundoff-error">
     The IEEE 754 standard and roundoff error
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#roundoff-error">
     Roundoff error
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#truncation-error">
   Truncation error
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exploring-parameter-spaces">
   Exploring parameter spaces
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#generating-data-from-simulations">
   Generating data from simulations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#normalizing-data">
   Normalizing data
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#feature-selection-and-design">
   Feature selection and design
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#deep-learning">
   Deep learning
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#test-case-overview">
     Test case overview
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#simple-feed-forward-neural-networks">
     Simple feed-forward neural networks
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#preparing-the-datasets">
     Preparing the datasets
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#generic-training-loop">
     Generic training loop
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#training-with-batches-of-data">
     Training with batches of data
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#learning-rate-adjustment">
     Learning rate adjustment
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#activation-functions">
     Activation functions
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#advanced-building-blocks">
     Advanced building blocks
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#dealing-with-uncertainty">
     Dealing with uncertainty
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#visualizing-prediction-errors">
     Visualizing prediction errors
    </a>
   </li>
  </ul>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Introduction to machine learning</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#floating-point-numbers">
   Floating point numbers
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-ieee-754-standard-and-roundoff-error">
     The IEEE 754 standard and roundoff error
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#roundoff-error">
     Roundoff error
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#truncation-error">
   Truncation error
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exploring-parameter-spaces">
   Exploring parameter spaces
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#generating-data-from-simulations">
   Generating data from simulations
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#normalizing-data">
   Normalizing data
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#feature-selection-and-design">
   Feature selection and design
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#deep-learning">
   Deep learning
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#test-case-overview">
     Test case overview
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#simple-feed-forward-neural-networks">
     Simple feed-forward neural networks
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#preparing-the-datasets">
     Preparing the datasets
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#generic-training-loop">
     Generic training loop
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#training-with-batches-of-data">
     Training with batches of data
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#learning-rate-adjustment">
     Learning rate adjustment
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#activation-functions">
     Activation functions
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#advanced-building-blocks">
     Advanced building blocks
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#dealing-with-uncertainty">
     Dealing with uncertainty
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#visualizing-prediction-errors">
     Visualizing prediction errors
    </a>
   </li>
  </ul>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <p><img alt="CC" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></p>
<p>This work is licensed under a <a class="reference external" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</p>
<section class="tex2jax_ignore mathjax_ignore" id="introduction-to-machine-learning">
<h1>Introduction to machine learning<a class="headerlink" href="#introduction-to-machine-learning" title="Permalink to this headline">#</a></h1>
<p>In this notebook, we cover the following topics:</p>
<ul class="simple">
<li><p>Floating point numbers</p>
<ul>
<li><p>The IEEE 754 standard</p></li>
<li><p>Roundoff error</p></li>
<li><p>Truncation error</p></li>
</ul>
</li>
<li><p>Exploring parameters spaces</p></li>
<li><p>Generating data with simulations</p></li>
<li><p>Normalizing data</p></li>
<li><p>Feature selection and design</p></li>
<li><p>Deep learning</p>
<ul>
<li><p>Test case overview</p></li>
<li><p>Simple feed-forward neural networks</p></li>
<li><p>Preparing the datasets</p></li>
<li><p>Generic training loop</p></li>
<li><p>Training with batches of data</p></li>
<li><p>Learning rate adjustment</p></li>
<li><p>Activation functions</p></li>
<li><p>Advanced building blocks</p></li>
<li><p>Dealing with uncertainty</p></li>
<li><p>Visualizing prediction errors</p></li>
</ul>
</li>
</ul>
<p><strong>Note:</strong> if you receive an import error related to the <em>paraview</em> module when executing the cell below, update the version of flowTorch as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># enter the Python environment</span>
<span class="n">source</span> <span class="n">ml</span><span class="o">-</span><span class="n">cfd</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">activate</span>
<span class="c1"># remove the old version of flowTorch</span>
<span class="n">pip</span> <span class="n">uninstall</span> <span class="n">flowtorch</span>
<span class="c1"># install the latest version</span>
<span class="n">pip</span> <span class="n">install</span> <span class="n">git</span><span class="o">+</span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">FlowModelingControl</span><span class="o">/</span><span class="n">flowtorch</span><span class="o">.</span><span class="n">git</span><span class="nd">@aweiner</span>
</pre></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from glob import glob
from typing import List, Tuple
from os.path import isdir, join
from shutil import copy
from copy import deepcopy
from time import time
from collections import defaultdict
import numpy as np
import torch as pt
from sklearn import metrics
import matplotlib.pyplot as plt
import pandas as pd
from flowtorch.data import FOAMDataloader

# make results reproducible
pt.manual_seed(0)

# increase plot resolution
plt.rcParams[&quot;figure.dpi&quot;] = 160

# create output directory
output = &quot;output&quot;
!mkdir -p $output
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Warning: TecplotDataloader can&#39;t be loaded. Most likely, the &#39;paraview&#39; module is missing.
Refer to the installation instructions at https://github.com/FlowModelingControl/flowtorch
If you are not using the TecplotDataloader, ignore this warning.
</pre></div>
</div>
</div>
</div>
<section id="floating-point-numbers">
<h2>Floating point numbers<a class="headerlink" href="#floating-point-numbers" title="Permalink to this headline">#</a></h2>
<p>You might be wondering why a lecture about ML starts with a section on floating point numbers. The answer is that a good understanding of how floating point numbers work often helps avoiding pitfalls both in ML and CFD. Computers can not represent real numbers with arbitrary precision, and when designing and implementing numerical algorithms, using the available precision effectively can make the difference between success and failure.</p>
<section id="the-ieee-754-standard-and-roundoff-error">
<h3>The IEEE 754 standard and roundoff error<a class="headerlink" href="#the-ieee-754-standard-and-roundoff-error" title="Permalink to this headline">#</a></h3>
<p>Floating point numbers are the digital representation of real numbers. The IEEE 754 standard defines how exactly most modern computers represent floating point numbers in terms of bits. One bit is always reserved for the sign <span class="math notranslate nohighlight">\(S\)</span>, and the remaining bits are shared by an integer exponent <span class="math notranslate nohighlight">\(E\)</span> and a binary <a class="reference external" href="https://en.wikipedia.org/wiki/Significand">mantissa</a> <span class="math notranslate nohighlight">\(M\)</span>. Using these three components, floating point numbers are written as (refer to chapter 1.1.1 in <em>Numerical Recipes</em>):
$<span class="math notranslate nohighlight">\(
  S \times M \times 2^{E-e},
\)</span><span class="math notranslate nohighlight">\(
where \)</span>e<span class="math notranslate nohighlight">\( is a fixed machine-dependent constant. In CFD and scientific computing in general, 64 bit floating point numbers are the standard, whereas most ML libraries use 32 bit floating point values by default. Floating point numbers with 32 bit are referred to as *single precision*, and the 64 bit counterpart is termed *double precision*. Single precision operations are more efficient, whereas double precision provides more significant decimal digits. The smallest number that can be still represented by the floating point type on our computer if we add it to \)</span>1.0$ is called <em>machine tolerance</em>. We can use the NumPy library function <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.finfo.html">finfo</a> to investigate mantissa, exponent, and machine tolerance for the most common data types <em>float32</em> and <em>float64</em>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>for dtype in [np.float32, np.float64]:
    finfo = np.finfo(dtype)
    print(f&quot;dtype: {finfo.dtype}&quot;)
    print(f&quot;Number of bits: {finfo.bits}&quot;)
    print(f&quot;Bits reserved for mantissa: {finfo.nmant}&quot;)
    print(f&quot;Bits reserved for exponent: {finfo.iexp}&quot;)
    print(&quot;Largest representable number: {:e}&quot;.format(finfo.max))
    print(&quot;Smallest representable number: {:e}&quot;.format(finfo.min))
    print(&quot;Machine tolerance: {:e}&quot;.format(finfo.eps))
    print(f&quot;Approximately accurate up to {finfo.precision} decimal digits&quot;)
    print(&quot;-&quot;*46)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>dtype: float32
Number of bits: 32
Bits reserved for mantissa: 23
Bits reserved for exponent: 8
Largest representable number: 3.402823e+38
Smallest representable number: -3.402823e+38
Machine tolerance: 1.192093e-07
Approximately accurate up to 6 decimal digits
----------------------------------------------
dtype: float64
Number of bits: 64
Bits reserved for mantissa: 52
Bits reserved for exponent: 11
Largest representable number: 1.797693e+308
Smallest representable number: -1.797693e+308
Machine tolerance: 2.220446e-16
Approximately accurate up to 15 decimal digits
----------------------------------------------
</pre></div>
</div>
</div>
</div>
</section>
<section id="roundoff-error">
<h3>Roundoff error<a class="headerlink" href="#roundoff-error" title="Permalink to this headline">#</a></h3>
<p>We can run a small experiment to observe the consequences of the limited machine tolerance in practice. The floating point data types in PyTorch are named in the same fashion as their NumPy counterparts.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>a = pt.tensor(1.0, dtype=pt.float32)
for b in [10**i for i in range(-1, -11, -1)]:
    print(&quot;1.0 + {:1.1e} = {:10.10f}&quot;.format(b, a+b))
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.0 + 1.0e-01 = 1.1000000238
1.0 + 1.0e-02 = 1.0099999905
1.0 + 1.0e-03 = 1.0010000467
1.0 + 1.0e-04 = 1.0001000166
1.0 + 1.0e-05 = 1.0000100136
1.0 + 1.0e-06 = 1.0000009537
1.0 + 1.0e-07 = 1.0000001192
1.0 + 1.0e-08 = 1.0000000000
1.0 + 1.0e-09 = 1.0000000000
1.0 + 1.0e-10 = 1.0000000000
</pre></div>
</div>
</div>
</div>
<p>In the print statement above, we display the result with 10 decimal digits. However, the <em>float32</em> type offers only up to 7 significant digits. All additional digits are filled up with somewhat random numbers. Moreover, when adding values like <span class="math notranslate nohighlight">\(10^{-8}\)</span> and smaller, the added small fraction falls victim to the <strong>roundoff</strong> error. After seeing the small experiment above, adding a value in the order of <span class="math notranslate nohighlight">\(O(10^{-8})\)</span> to another value that is <span class="math notranslate nohighlight">\(O(1)\)</span> will hopefully trigger your roundoff alarm sirens. However, the difficulty with numerical precision is not always so apparent. Consider some points <span class="math notranslate nohighlight">\((x_i, y_i)\)</span> with <span class="math notranslate nohighlight">\(-0.01\le x \le 0.01\)</span> and <span class="math notranslate nohighlight">\(1 \le y \le 10\)</span>. Now, we want to fit a polynomial to our data, say <span class="math notranslate nohighlight">\(y(x) = ax^4+bx^3+cx^2+dx+e\)</span>, so we construct the necessary polynomial features by computing the corresponding powers of <span class="math notranslate nohighlight">\(x\)</span>. The constants are determined using some gradient-based iterative algorithm like gradient decent. At the beginning of the optimization, the weights (coefficients) <span class="math notranslate nohighlight">\(a\)</span> to <span class="math notranslate nohighlight">\(e\)</span> are typically initialized by sampling random numbers between zero and one. Considering the polynomial form again, most likely the optimization will be affected by roundoff errors (using single precision) because the first term <span class="math notranslate nohighlight">\(ax^4\)</span> will be always smaller than <span class="math notranslate nohighlight">\(10^{-8}\)</span> and the last term <span class="math notranslate nohighlight">\(e\)</span> will be <span class="math notranslate nohighlight">\(O(1)\)</span>. In practice, we can mitigate such scenarios to some extend by normalizing the data, as we will learn later on in this notebook.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>for x in pt.arange(-0.01, 0.011, 0.0025):
    print(&quot;x={:+1.4e}, x**2={:1.4e}, x**3={:+1.4e}, x**4={:1.4e}&quot;.format(x, x**2, x**3, x**4))
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>x=-1.0000e-02, x**2=1.0000e-04, x**3=-1.0000e-06, x**4=1.0000e-08
x=-7.5000e-03, x**2=5.6250e-05, x**3=-4.2187e-07, x**4=3.1641e-09
x=-5.0000e-03, x**2=2.5000e-05, x**3=-1.2500e-07, x**4=6.2500e-10
x=-2.5000e-03, x**2=6.2500e-06, x**3=-1.5625e-08, x**4=3.9062e-11
x=+0.0000e+00, x**2=0.0000e+00, x**3=+0.0000e+00, x**4=0.0000e+00
x=+2.5000e-03, x**2=6.2500e-06, x**3=+1.5625e-08, x**4=3.9062e-11
x=+5.0000e-03, x**2=2.5000e-05, x**3=+1.2500e-07, x**4=6.2500e-10
x=+7.5000e-03, x**2=5.6250e-05, x**3=+4.2187e-07, x**4=3.1641e-09
x=+1.0000e-02, x**2=1.0000e-04, x**3=+1.0000e-06, x**4=1.0000e-08
</pre></div>
</div>
</div>
</div>
<p>In iterative solution algorithms, roundoff errors can be even more challenging. Consider the following two operations, in which we get a roundoff error because the intermediate result, <span class="math notranslate nohighlight">\(1/3\)</span> can’t be represented exactly as a binary number:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>a = pt.tensor(1.0)
print(&quot;a={:1.10f}&quot;.format(a))
b = a - 2.0/3.0
print(&quot;b={:1.10f}&quot;.format(b))
a = 3.0*b
print(&quot;a={:1.10f}&quot;.format(a))
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>a=1.0000000000
b=0.3333333135
a=0.9999999404
</pre></div>
</div>
</div>
</div>
<p>Now let’s simulate an simplified iterative solution algorithm, in which we execute the same options many times in a row:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def iterate(n_iter: float = 1):
    a = pt.tensor(1.0)
    for _ in range(n_iter):
        b = a - 2/3
        a = 3.0 * b
    print(f&quot;a={a:1.10f} after {n_iter:1d} iteration(s)&quot;)

for i in range(1, 10):
    iterate(i)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>a=0.9999999404 after 1 iteration(s)
a=0.9999997616 after 2 iteration(s)
a=0.9999992251 after 3 iteration(s)
a=0.9999976158 after 4 iteration(s)
a=0.9999927878 after 5 iteration(s)
a=0.9999783039 after 6 iteration(s)
a=0.9999348521 after 7 iteration(s)
a=0.9998044968 after 8 iteration(s)
a=0.9994134307 after 9 iteration(s)
</pre></div>
</div>
</div>
</div>
<p>The discrepancy between single precision in ML and double precision in CFD is usually not critical, especially if ML is used as a means of post-processing CFD data. The situation might change if the ML model is employed somewhen during the simulation’s runtime. A save option is setting the default precision of the ML library to double precision. In PyTorch, this option can be set globally at the beginning of the program.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>x = pt.tensor(1.0)
print(x.dtype)
pt.set_default_dtype(pt.float64)
x = pt.tensor(1.0)
print(x.dtype)
pt.set_default_dtype(pt.float32)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>torch.float32
torch.float64
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="truncation-error">
<h2>Truncation error<a class="headerlink" href="#truncation-error" title="Permalink to this headline">#</a></h2>
<p>In contrast to the roundoff error, the truncation error is not a hardware property but results from the discrete approximation of continuous quantities. For example, we could approximate the integral of <span class="math notranslate nohighlight">\(y(x) = x^2\)</span>:
$<span class="math notranslate nohighlight">\(
  \int\limits_0^1 x^2 \mathrm{d}x = 1/3
\)</span>$
numerically by using the trapezoidal rule.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>max_intervals = 40
residual = []
for n_int in range(2, max_intervals+1):
    x = pt.linspace(0, 1, n_int)
    y = x**2
    dx = (1.0-0.0) / n_int
    integral = 0.5 * (y[0:-1]+y[1:]).sum() * dx
    residual.append(abs(integral - 1.0/3.0))

plt.plot(range(2, max_intervals+1), residual, label=&quot;trapezoidal rule&quot;)
plt.plot([2, max_intervals], pt.tensor([max_intervals, 2])*(0.005), label=&quot;first order slope&quot;)
plt.xlabel(r&quot;$1/\Delta x$&quot;)
plt.ylabel(&quot;residual&quot;)
plt.xscale(&quot;log&quot;)
plt.yscale(&quot;log&quot;)
#plt.gca().set_aspect(&quot;equal&quot;)
plt.legend()
plt.savefig(f&quot;{output}/residual_trapezoidal_rule.svg&quot;, bbox_inches=&quot;tight&quot;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/ml_intro_15_0.png" src="../_images/ml_intro_15_0.png" />
</div>
</div>
<p>As we can see, the residual decreases proportionally to the size of discrete elements into which we divide the interval. So, even if the computer provided perfect accuracy, it would still take infinitely small elements to reach perfect accuracy. CFD simulations employing the finite volume method are typically second order accurate, so the truncation error decreases proportionally to the square of the element size.</p>
</section>
<section id="exploring-parameter-spaces">
<h2>Exploring parameter spaces<a class="headerlink" href="#exploring-parameter-spaces" title="Permalink to this headline">#</a></h2>
<p>Suppose we want to conduct a CFD parameter study in which we vary the Reynolds number <span class="math notranslate nohighlight">\(Re\)</span> and record the drag coefficient <span class="math notranslate nohighlight">\(c_d\)</span>. Our aim would be to create an ML-based surrogate model based on the pairs <span class="math notranslate nohighlight">\(Re_i\)</span> and <span class="math notranslate nohighlight">\(c_{d,i}\)</span>. Let’s assume we know a range for <span class="math notranslate nohighlight">\(Re\)</span> that we are particularly interested in. An important question before starting the simulations is now how to pick suitable <span class="math notranslate nohighlight">\(Re\)</span> values in the specified range. In general, we want our sampling to be:</p>
<ol class="simple">
<li><p>unbiased - every point has the same chance of being selected</p></li>
<li><p>efficient - we want to run as few simulations as possible</p></li>
<li><p>homogeneous - we want the samples to be homogeneously distributed across the parameter space</p></li>
</ol>
<p>Let’s say we want to run <span class="math notranslate nohighlight">\(N_s\)</span> simulations. Intuitively, you may want to distribute the <span class="math notranslate nohighlight">\(N_s\)</span> points equally spaced across the Reynolds number range, and there are good arguments to do so. However, there are at least two problems with this approach:</p>
<ol class="simple">
<li><p>it does not scale to multiple dimensions, e.g., if we vary more than one parameter; if we want to treat every parameter equal, we should pick <span class="math notranslate nohighlight">\(N_s\)</span> points in every parameter range and perform simulation for all parameter permutations; for <span class="math notranslate nohighlight">\(d\)</span> parameters, this strategy would require running <span class="math notranslate nohighlight">\(N_s^d\)</span> simulations; the number of sample points increases exponentially</p></li>
<li><p>it is biased because not every point has the same chance of being sampled; the plot below show a somewhat artificial and extreme effect of bias; the true signal is periodic but the samples suggest that there is basically no correlation between input and output</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>x = pt.linspace(0.0, 20*np.pi, 300)
y = pt.sin(x)

x_sample_1 = pt.linspace(0, 20.1*np.pi, 11) + (2*pt.rand(11)-1)*0.1
x_sample_2 = pt.linspace(0, 20*np.pi, 21) + (2*pt.rand(21)-1)*0.1

plt.plot(x, y, alpha=0.5, ls=&quot;--&quot;, label=&quot;true function&quot;)
plt.scatter(x_sample_1, pt.sin(x_sample_1) +
            (2*pt.rand(11)-1)*0.05, label=&quot;sample 1&quot;)
plt.scatter(x_sample_2, pt.sin(x_sample_2) + (2*pt.rand(21)-1)
            * 0.05, marker=&quot;x&quot;, label=&quot;sample 2&quot;, zorder=6)
plt.xlim(0, 20.1*np.pi)
plt.xlabel(r&quot;$x$&quot;)
plt.ylabel(r&quot;$y$&quot;)
plt.legend(ncol=3, loc=1)
plt.savefig(f&quot;{output}/biased_sampling.svg&quot;, bbox_inches=&quot;tight&quot;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/ml_intro_17_0.png" src="../_images/ml_intro_17_0.png" />
</div>
</div>
<p>To make the samples unbiased, we should select the samples randomly. However, selecting <span class="math notranslate nohighlight">\(N_s\)</span> points at random may give you some stomach ache, too, because large portions of the parameter space might remain unexplored. Random sampling is relatively inefficient.</p>
<p>A good compromise between the homogeneity of equally spaced sample points and efficient unbiased sampling is <em>latin hypercube sampling</em> (LHS). If the goal is to perform <span class="math notranslate nohighlight">\(N_s\)</span> simulations, each parameter range is equally divided into <span class="math notranslate nohighlight">\(N_s\)</span> sections. Then, one random sample is drawn in each section of each parameter. If there is more than one parameter, the samples drawn from the individual parameter ranges are shuffled. Combining (stacking) the shuffled individual samples yields the final samples in the full parameter space. Below, we implement a simple version of LHS in PyTorch.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def lhs_sampling(x_min, x_max, n_samples):
    assert len(x_min) == len(x_max)
    n_parameters = len(x_min)
    samples = pt.zeros((n_parameters, n_samples))
    for i, (lower, upper) in enumerate(zip(x_min, x_max)):
        bounds = pt.linspace(lower, upper, n_samples+1)
        rand = bounds[:-1] + pt.rand(n_samples) * (bounds[1:]-bounds[:-1])
        samples[i, :] = rand[pt.randperm(n_samples)]
    return samples


N_s = 10
samples = lhs_sampling([0, 90], [5, 100], N_s)
plt.scatter(samples[0, :], samples[1, :], zorder=6, label=&quot;samples&quot;)
plt.xticks(pt.linspace(0, 5, N_s+1))
plt.yticks(pt.linspace(90, 100, N_s+1))
plt.grid(True, ls=&quot;--&quot;)
plt.legend()
plt.xlabel(&quot;parameter 1&quot;)
plt.ylabel(&quot;parameter 2&quot;)
plt.title(&quot;latin hypercube sampling&quot;)
plt.savefig(f&quot;{output}/lhs_sampling.svg&quot;, bbox_inches=&quot;tight&quot;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/ml_intro_19_0.png" src="../_images/ml_intro_19_0.png" />
</div>
</div>
</section>
<section id="generating-data-from-simulations">
<h2>Generating data from simulations<a class="headerlink" href="#generating-data-from-simulations" title="Permalink to this headline">#</a></h2>
<p>The previous section covered how to sample a parameter space efficiently and unbiased. This section outlines some tools and strategies to run automated CFD parameter studies. Every parameter study should start with a tested and validated base simulation. Typical criteria for a good base simulation are similar to the ones of any good CFD simulation:</p>
<ul class="simple">
<li><p>the setup correctly reflects the mathematical problem</p></li>
<li><p>a mesh dependency study was performed, and the results show sufficiently low mesh dependency</p></li>
<li><p>key performance quantities were validated against high-fidelity reference data</p></li>
<li><p>the setup is optimized; mesh-independent results are obtained as quickly as possible</p></li>
</ul>
<p>The easiest way to perform a parameter study is to create a copy of the base simulation, modify the parameters in question, and run the new setup. However, the change of one parameter often requires the adjustment of related settings, too. For example, increasing the inlet velocity or the pressure gradient driving the flow leads to an increased Courant number if the mesh remains unchanged. Since the increased Courant number might cause stability issues, the numerical time step should be lowered. Tools like OpenFOAM support time step adjustment based on the maximum Courant number, which simplifies parameter changes to some extend. If the time step needs adjustment, the characteristic time scale of the problem has probably changed, too. For example, the vortex shedding frequency displayed by the flow past a cylinder increases proportionally to the Reynolds number in the range <span class="math notranslate nohighlight">\(80 &lt; Re &lt; 1000\)</span>. If our aim is to run the simulation until a quasi-steady vortex shedding is reached, the required physical simulation time decreases as the Reynolds number increases. Running all simulation up to the same physical end time would be a waste of resources.</p>
<p>On the other hand side, changing too many parameters at once might make the setup unnecessarily complex and could introduce unforeseeable side effects. Mesh generation, for example, is often an intricate and time consuming process, such that we may want to run all simulations employing the same mesh. However, how do we ensure that the results remain mesh independent despite an increase, say, of the Reynolds number? A simple strategy for this scenario would be to pick the most demanding case in terms of mesh resolution and to build the mesh based on this configuration. Of course, the computational efficiency for less demanding cases decreases, but building optimized meshes for all conditions might be untractable.</p>
<p>Once the base case is ready, we can write a script that copies, modifies, and runs new setups. Shell or Python scripts are good choices to automate the process. Shell programming is a good option for simple parameter variations and to automate workflows in general. The <em>Allrun</em> scripts provided in the <em>test_cases</em> are simple recipes to perform a list processing steps required to perform the simulation. Python scripts are more powerful but require a Python interpreter and possibly additional library dependencies. Python also allows executing shell commands via the standard library functions <a class="reference external" href="https://docs.python.org/3/library/os.html#os.system">os.system()</a> or <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen">subprocess.Popen()</a>. The <em>system</em> function is rather limited but sufficient for running simple and short shell commands. For example, the lines</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cmd</span> <span class="o">=</span> <span class="s2">&quot;sed -i &#39;s/old_text/new_text/&#39; exampleDict&quot;</span>
<span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>
</pre></div>
</div>
<p>would search the file <em>exampleDict</em> for the string <em>old_text</em> and replace the text with <em>new_text</em>. On the other hand side, <em>Popen</em> offers greater flexibility in terms of process control. The same command as above executed with <em>subprocess</em> would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;sed&quot;</span><span class="p">,</span> <span class="s2">&quot;-i&quot;</span><span class="p">,</span> <span class="s2">&quot;&#39;s/old_text/new_text/&#39;&quot;</span><span class="p">,</span> <span class="s2">&quot;exampleDict&quot;</span><span class="p">]</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">Popen</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>
<span class="c1"># print exit code to check if execution was successful</span>
<span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">poll</span><span class="p">())</span>
</pre></div>
</div>
<p>In the case of OpenFOAM simulations, the <em>Popen</em> function is a good candidate to perform individual simulations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">run_simulation</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Execute a simulation by running the *Allrun* script.</span>

<span class="sd">    :param path: path to simulation folder</span>
<span class="sd">    :type path: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">return_code</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s2">&quot;./Allrun&quot;</span><span class="p">],</span> <span class="n">cwd</span><span class="o">=</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">return_code</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Simulation </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2"> completed successfully.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: simulation </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2"> failed.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>If we had a list of paths to modified simulations, we could loop over the list and use the <em>run_simulation</em> function to execute one simulation after the other. We can accelerate the execution process if we have enough resources to perform multiple simulations at once. Python supports running multiple processes at once via the <em>multiprocessing</em> module. A suitable workflow making use of the <em>run_simulation</em> function defined before, would be to create a process pool based on the number of available CPU cores and to map all the list of all simulation paths to the <em>run_simulation</em> function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">simulations</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;./sim_0/&quot;</span><span class="p">,</span> <span class="s2">&quot;./sim_1/&quot;</span><span class="p">,</span> <span class="s2">&quot;./sim_2/&quot;</span><span class="p">]</span>
<span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="k">with</span> <span class="n">pool</span><span class="p">:</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">run_simulation</span><span class="p">,</span> <span class="n">simulations</span><span class="p">)</span>
</pre></div>
</div>
<p>Employing the code snippet above, simulations zero and one would be run roughly at the same time. Whichever subprocess finishes first will then execute simulation two.</p>
</section>
<section id="normalizing-data">
<h2>Normalizing data<a class="headerlink" href="#normalizing-data" title="Permalink to this headline">#</a></h2>
<p>Suppose we created a dataset, in which an airfoil’s drag coefficient was determined for several Reynolds numbers <span class="math notranslate nohighlight">\(Re\)</span> and angles of attack <span class="math notranslate nohighlight">\(\alpha\)</span>. The Reynolds number ranges between <span class="math notranslate nohighlight">\(Re=10\times 10^6\)</span> and <span class="math notranslate nohighlight">\(Re=20\times 10^6\)</span>. The angle of attack was varied between <span class="math notranslate nohighlight">\(\alpha = 0^\circ\)</span> and <span class="math notranslate nohighlight">\(\alpha = 4^\circ\)</span>. Now we want to build a surrogate model by means of regression. Based on section 1, it should be clear that combining the features <span class="math notranslate nohighlight">\(Re\)</span> and <span class="math notranslate nohighlight">\(\alpha\)</span> directly in a model is not a good idea. So, how can we improve the situation? A simple solution is to normalize both features. There are two common ways to normalize any kind of data. In a min-max-scaling, each feature <span class="math notranslate nohighlight">\(x_i\)</span> are scaled to the range <span class="math notranslate nohighlight">\([0,1]\)</span>:
$<span class="math notranslate nohighlight">\(
  \tilde{x}_i = \frac{x_i-x_{i,min}}{x_{i,max}-x_{i,min}}.
\)</span><span class="math notranslate nohighlight">\(
Alternatively, the equation above could also be rescaled to the range \)</span>[-1,1]<span class="math notranslate nohighlight">\(. Min-max scaling works great if the input data are clean, e.g., if there are no outliers. A normalization technique less sensitive to outliers scales the features with their mean \)</span>\mu_x<span class="math notranslate nohighlight">\( and standard deviation \)</span>\sigma_x<span class="math notranslate nohighlight">\(:
\)</span><span class="math notranslate nohighlight">\(
  \tilde{x}_i = \frac{x_i-\mu_{x_i}}{\sigma_{x_i}}.
\)</span><span class="math notranslate nohighlight">\(
The re-scaled features have zero mean and unit standard deviation. These properties are also the reason why this scaling is a good choice when training neural networks employing sigmoid and hyperbolic tangents activation functions. These activation functions are not so popular any longer in most fields using deep learning. However, for PINNs they are essential because one can compute arbitrarily many derivatives of both functions. Without going further into detail about neural networks, it is sufficient to now that we do not want activation functions to *saturate*, which mean to become insensitive to the input. Looking at the sigmoid function depicted below, saturation occurs if the argument becomes too small or too low. Data normalized by their mean and standard deviation lead to activation values in the most sensitive range (the slope is the highest around \)</span>x=0$).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def sigmoid(x: pt.Tensor) -&gt; pt.Tensor:
    &quot;&quot;&quot;Compute the sigmoid function.

    :param x: input argument
    :type x: pt.Tensor
    :return: sigmoid of x
    :rtype: pt.Tensor
    &quot;&quot;&quot;
    return 1.0 / (1.0 + pt.exp(-x))


x = pt.linspace(-10, 10, 40)
plt.plot(x, sigmoid(x), label=r&quot;$\sigma (x)$&quot;)
plt.plot(x, sigmoid(x)*(1.0-sigmoid(x)), ls=&quot;--&quot;,
         label=r&quot;$\mathrm{d}\sigma (x)/\mathrm{d} x$&quot;)
plt.xlabel(r&quot;$x$&quot;)
plt.xlim(-10, 10)
plt.legend()
plt.savefig(f&quot;{output}/sigmoid_function.svg&quot;, bbox_inches=&quot;tight&quot;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/ml_intro_22_0.png" src="../_images/ml_intro_22_0.png" />
</div>
</div>
<p>Clustering is another great example to demonstrate the importance of normalization. Suppose we have the following data points for Reynolds number <span class="math notranslate nohighlight">\(Re\)</span> and lift coefficient <span class="math notranslate nohighlight">\(c_l\)</span>:</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="text-align:center head"><p><span class="math notranslate nohighlight">\(i\)</span></p></th>
<th class="text-align:center head"><p><span class="math notranslate nohighlight">\(Re\)</span></p></th>
<th class="text-align:center head"><p><span class="math notranslate nohighlight">\(c_l\)</span></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-align:center"><p>1</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(10\times 10^6\)</span></p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(0.3\)</span></p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>2</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(12\times 10^6\)</span></p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(0.12\)</span></p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p>3</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(15\times 10^6\)</span></p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(0.11\)</span></p></td>
</tr>
</tbody>
</table>
<p>Clustering is about grouping similar data points. Eyeballing the data, you probably see that something significant must have happened in the range <span class="math notranslate nohighlight">\(10\times 10^6 &lt; Re &lt; 12\times 10^6\)</span> because the lift dropped to about one third for the measurement points 2 and 3. If you were tasked to sort similar data points into two different bins, you would probably separate point 1 from the points 2 and 3. To automate the clustering, we need a more precise definition of the notion of similarity we used so far. The most common metric to measure the distance between data points is the <a class="reference external" href="https://en.wikipedia.org/wiki/Euclidean_distance">Euclidean norm</a>. For the data point above, the distances are:</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="text-align:center head"><p>points</p></th>
<th class="text-align:center head"><p>distance</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-align:center"><p>1-2</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(2\times 10^6\)</span></p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>1-3</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(5\times 10^6\)</span></p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p>2-3</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(3\times 10^6\)</span></p></td>
</tr>
</tbody>
</table>
<p>According to the Euclidean distance, we should rather group points 1 and two together because the distance between them is the smallest. Of course, this outcome is not really what we wanted. Again, normalization can help the situation. The min-max-normalized data are:</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="text-align:center head"><p><span class="math notranslate nohighlight">\(i\)</span></p></th>
<th class="text-align:center head"><p><span class="math notranslate nohighlight">\(\tilde{Re}\)</span></p></th>
<th class="text-align:center head"><p><span class="math notranslate nohighlight">\(\tilde{c}_l\)</span></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-align:center"><p>1</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(0\)</span></p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(1\)</span></p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>2</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(0.4\)</span></p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(0.05\)</span></p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p>3</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(1\)</span></p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(0\)</span></p></td>
</tr>
</tbody>
</table>
<p>The distances between the points are now:</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="text-align:center head"><p>points</p></th>
<th class="text-align:center head"><p>distance</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-align:center"><p>1-2</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(1.03\)</span></p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>1-3</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(1.41\)</span></p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p>2-3</p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(0.60\)</span></p></td>
</tr>
</tbody>
</table>
<p>This time, the distance reflects out initial evaluation. The distance between points 2 and 3 is the smallest. In higher dimensions, seeing such normalization-related issue is not straight forward. Therefore, it is good practice to <strong>always</strong> normalize all the data, features as well as labels. In the worst case, normalization costs you a few extra operations to scale and re-scale the model’s input and output. In most cases, normalization improves accuracy and accelerates the training.</p>
<p>Finally, if the data points of a feature are very unevenly distributed in the feature space, it might be sensible to work with the logarithm of the feature instead of the feature itself. An example displaying the usefulness of logarithmic scaling is part of the next lecture.</p>
</section>
<section id="feature-selection-and-design">
<h2>Feature selection and design<a class="headerlink" href="#feature-selection-and-design" title="Permalink to this headline">#</a></h2>
<p>Selecting and designing good features is one of the most essential parts of applying ML to CFD problems. Sometimes, the features and labels are naturally given, and it is straight forward to identify the mapping that the ML model has to perform. Suppose we have a car model and want to create a surrogate model predicting the drag as a function of the Reynolds number based on a couple of CFD simulations. In the simulation, the inlet velocity may be defined to impose a certain Reynolds number und the aerodynamic forces acting on the car result from the velocity and pressure fields. There would be only one feature and one label, and we could choose from a variety of regression algorithms to build a suitable surrogate model. However, sometimes it can be sensible to design additional features based on the extracted raw data. Potential reasons for designing new features could be:</p>
<ul class="simple">
<li><p>to enforce mathematical constraints like symmetry or boundedness</p></li>
<li><p>to leverage known (physical) relations</p></li>
<li><p>to reduce the variance in the data before training</p></li>
</ul>
<p>In summary, one could say that feature design serves the purpose to simplify the ML problem. Good features accelerate the model training and often lead to smaller yet more accurate models. However, care has to be taken when selecting or designing features. It is essential to know right from the beginning what exactly the model is going to be used for in a target application. One common pitfall is basing the model on features that are not (easily) available in the target application. For example, when deriving models for low-fidelity simulations based on high fidelity data, we must first convert the high-fidelity data into features that are also available during the runtime of the low-fidelity simulation. To give a more specific example, direct numerical simulations (DNS) data may be used for turbulence modeling in large eddy simulation (LES) or Reynolds-averaged Navier-Stokes (RANS) simulation approaches. In all approaches, there is going to be a <em>velocity field</em>. However, the mathematical definition of velocity and other quantities varies in each simulation. DNS provides spatially and temporally resolved fields, while LES works with filtered and RANS with time-averaged information. Therefore, the first processing step should be to filter or average the DNS data before exploring and designing new features. Not only the mathematical definition of features but also assumptions about the spatial arrangement might be important. For example, DNS solvers might operate on structured Cartesian meshes, while solver for industrial applications operate on unstructured meshes with arbitrary topology. While it might seem a good idea at first to use specialized neural network architectures like convolutional neural networks to process the array-like DNS data, such a model would be hard or even impossible to apply in the unstructured target solver.</p>
<p>A general rule of thumb for designing additional features is to have rather too many than too few features. Not all features should and will be used for model training since the model may become unnecessary complex or prone to over-fitting the data. However, instead of eliminating features manually, one could consider employing feature exploration and selection strategies. Some examples are:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://stackoverflow.com/questions/39409866/correlation-heatmap">correlation heatmaps</a> visualize the linear correlation between different features and labels; if the correlation between a feature and a label is strong, the feature might be a good candidate for modeling</p></li>
<li><p>sequential forward/backward selection performs eliminatory rounds with varying numbers and combinations of features; each round, one feature is removed (backward selection) or added (forward selection)</p></li>
<li><p>decision trees or ensemble variants thereof have a built-in <a class="reference external" href="https://scikit-learn.org/stable/auto_examples/ensemble/plot_forest_importances.html">feature importance</a> to rank features (based on the internal criteria at each node of the tree)</p></li>
<li><p><a class="reference external" href="https://scikit-learn.org/stable/modules/permutation_importance.html#permutation-importance">permutation feature importance</a> shuffles the values of a single feature randomly and observes how the performance of a training model is affected</p></li>
</ul>
<p>The feature ranking strategies have different pros and cons. Sequential backward selection, for example, yields a meaningful ranking in most cases but can be very expensive to compute. Decision trees, on the other hand, are easily trained, but their <em>feature importance</em> is more susceptible to small changes in the data.</p>
</section>
<section id="deep-learning">
<h2>Deep learning<a class="headerlink" href="#deep-learning" title="Permalink to this headline">#</a></h2>
<section id="test-case-overview">
<h3>Test case overview<a class="headerlink" href="#test-case-overview" title="Permalink to this headline">#</a></h3>
<p>To demonstrate the training and evaluation of neural networks, we need some training data. Here, we work with developed velocity profiles of a 1D channel flow simulation. Conducting the parameter study to create the data is part of the accompanying exercise session. The channel flow is characterized by the Reynolds number <span class="math notranslate nohighlight">\(Re=2\delta\bar{U}/\nu\)</span>, where <span class="math notranslate nohighlight">\(\delta\)</span> is one half of the channel height, <span class="math notranslate nohighlight">\(\bar{U}\)</span> is the average velocity along the channel, and <span class="math notranslate nohighlight">\(\nu\)</span> is the kinematic viscosity. In the parameter study, 16 different values <span class="math notranslate nohighlight">\( 10^4 &lt; Re &lt; 10^5\)</span> were sampled with latin hypercube sampling and the corresponding simulations executed. The main output of a single simulation is the velocity along the channel <span class="math notranslate nohighlight">\(u_x\)</span> at several distances <span class="math notranslate nohighlight">\(y\)</span> normal to the channel wall. Our goal is creating a model that provides us with the normalized streamwise velocity <span class="math notranslate nohighlight">\(\tilde{u}_x = u_x/\bar{U}_{max}\)</span> value for a given normalized distance from the wall <span class="math notranslate nohighlight">\(\tilde{y} = y/(2\delta)\)</span> and the Reynolds number:
$<span class="math notranslate nohighlight">\(
  \tilde{u}_{x} = f_\theta(\tilde{y}, Re).
\)</span><span class="math notranslate nohighlight">\(
The features are \)</span>\tilde{y}<span class="math notranslate nohighlight">\( and \)</span>Re<span class="math notranslate nohighlight">\(. The label is \)</span>\tilde{u}_x<span class="math notranslate nohighlight">\(. Such a model could be the basis for improving the accuracy of the near wall region of turbulent flow simulations. Note that there are more clever ways to normalize \)</span>y<span class="math notranslate nohighlight">\( and \)</span>u_x$, but we stick to the version above to make the learning slightly more challenging.</p>
<p>As a first step, we load the velocity profiles, the points normal to the wall at which the velocity values are defined, and the Reynolds numbers.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>cases = glob(&quot;../exercises/boundary_layer_1D_variation/Ub_*&quot;)
cases = sorted(cases, key=lambda case: float(case.split(&quot;_&quot;)[-1]))
loader = FOAMDataloader(cases[0])
y = loader.vertices[:, 1]
u_x = pt.zeros((y.shape[0], len(cases)))
for i, case in enumerate(cases):
    loader = FOAMDataloader(case)
    u_x[:, i] = loader.load_snapshot(&quot;U&quot;, loader.write_times[-1])[:, 0]

Ubar = pt.tensor([float(case.split(&quot;_&quot;)[-1]) for case in cases])
print(&quot;Shape of data matrix: &quot;, u_x.shape)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Could not find precomputed cell centers and volumes.
Computing cell geometry from scratch (slow, not recommended for large meshes).
To compute cell centers and volumes in OpenFOAM, run:

postProcess -func &quot;writeCellCentres&quot; -constant -time none
postProcess -func &quot;writeCellVolumes&quot; -constant -time none
Shape of data matrix:  torch.Size([200, 16])
</pre></div>
</div>
</div>
</div>
<p>There are 200 points normal to the wall and 16 different Reynolds numbers. Each velocity profile contains 200 values and all 16 profiles assembled yield a <span class="math notranslate nohighlight">\(200\times 16\)</span> tensor. Since the data are low-dimensional, we have the luxury of being able to visualize the full dataset all at once.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>delta, nu = 0.5, 1.0e-5
Re = pt.tensor([Ub.item()*2*delta/nu for Ub in Ubar])
for i in range(len(Re)):
    plt.plot(u_x[:, i], y, label=r&quot;$Re={:1.0f}$&quot;.format(round(Re[i].item(), 0)))
plt.xlabel(r&quot;$u_x$&quot;)
plt.ylabel(r&quot;$y$&quot;)
plt.xlim(0.0, 1.1)
plt.ylim(-0.01, 0.5)
plt.legend(loc=&quot;upper center&quot;, ncol=4, bbox_to_anchor=[0.5, 1.3])
plt.savefig(f&quot;{output}/developed_1d_profile.svg&quot;, bbox_inches=&quot;tight&quot;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/ml_intro_27_0.png" src="../_images/ml_intro_27_0.png" />
</div>
</div>
<p>The normalization visualized does not alter the nature of the data significantly. However, if <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(u_x\)</span> had very different values ranges, normalizing by the channel height and the average velocity would bring both quantities much closer to the desired range about <span class="math notranslate nohighlight">\(O(1)\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>for i in range(len(Re)):
    plt.plot(u_x[:, i]/Ubar.max(), y/(2*delta), label=r&quot;$Re={:1.0f}$&quot;.format(round(Re[i].item(), 0)))
plt.xlabel(r&quot;$\tilde{u}_x$&quot;)
plt.ylabel(r&quot;$\tilde{y}$&quot;)
plt.xlim(0.0, 1.2)
plt.ylim(-0.01, 0.5)
plt.legend(loc=&quot;upper center&quot;, ncol=4, bbox_to_anchor=[0.5, 1.3])
plt.savefig(f&quot;{output}/developed_1d_profile_normalized.svg&quot;, bbox_inches=&quot;tight&quot;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/ml_intro_29_0.png" src="../_images/ml_intro_29_0.png" />
</div>
</div>
<p>A first inspection of the data shows the expected behavior. As the Reynolds number increases, the average channel velocity increases and the profiles become steeper close to the wall. These observations are a good first sanity check. However, we should validate the data against known results for the same or similar settings. Luckily, the problem is relatively simple such that we can compare the outcome against an existing analytical function. We know that close to the wall, the velocity profile should follow first a linear and then a logarithmic trend. This relation is know as <a class="reference external" href="https://en.wikipedia.org/wiki/Law_of_the_wall">law of the wall</a>. Spalding’s function comines both linear and logarithmic zones. However, Spalding’s function is given in so-called inner coordinates:
$<span class="math notranslate nohighlight">\(
  u_\tau = \sqrt{\nu\partial_yu_x|_{y=0}/\rho},\quad y^+ = yu_\tau/\nu,\quad u^+ = u_x/u_\tau.
\)</span><span class="math notranslate nohighlight">\(
The velocity \)</span>u_\tau<span class="math notranslate nohighlight">\( is also called shear stress or friction velocity. Since the simulation is incompressible, we assume a density of unity. Spalding's function is then given as:
\)</span><span class="math notranslate nohighlight">\(
  y^+ = u^+ + \left[e^{u^+\kappa} - 1 - u^+\kappa\left(1+u^+\kappa/2\right) - \left(u^+\kappa\right)^3/6\right] / E,
\)</span><span class="math notranslate nohighlight">\(
where the constants have values of \)</span>E=9.8<span class="math notranslate nohighlight">\( and \)</span>\kappa = 0.41$.</p>
<p>To compare against Spalding’s function, we have to convert the velocity profiles into inner coordinates. The velocity’s slope at the wall <span class="math notranslate nohighlight">\(\partial_yu_x|_{y=0}\)</span> can be approximated for each velocity profile using finite differences and assuming a velocity of zero at the wall. The linear approximation of the slope is reasonable since the boundary layer is fully resolved by the mesh. In the figure below, we can observe how the simulation data nicely collapse almost into a single profile, which is in agreement with Spalding’s function.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def spalding(up: pt.Tensor, E: float=9.8, kappa: float=0.41) -&gt; pt.Tensor:
    &quot;&quot;&quot;Compute Spalding&#39;s velocity profile.

    :param up: velocity in inner coordinates U-plus
    :type up: pt.Tensor
    :param E: wall roughness constant, defaults to 9.8
    :type E: float, optional
    :param kappa: van Kármán constant, defaults to 0.41
    :type kappa: float, optional
    :return: distance in inner coordinates y-plus
    :rtype: pt.Tensor
    &quot;&quot;&quot;
    upk = up*kappa
    temp = pt.exp(upk) - 1 - upk*(1+upk/2) - upk**3/6
    return up + temp/E

dy_u_x = (0.0 - u_x[0, :]) / (0.0 - y[0])
U_tau = pt.sqrt(nu * dy_u_x)

for i, Ub in enumerate(Ubar):
    y_plus = y*U_tau[i]/nu
    U_plus = u_x[:, i] / U_tau[i]
    plt.plot(y_plus, U_plus, lw=1, ls=&quot;--&quot;)

U_spalding = pt.linspace(0.01, 25, 100)
plt.plot(spalding(U_spalding), U_spalding, c=&quot;k&quot;, label=&quot;Spalding&#39;s function&quot;)
plt.xlabel(r&quot;$y^+$&quot;)
plt.ylabel(r&quot;$u^+$&quot;)
plt.xlim(0.01, 2500)
plt.xscale(&quot;log&quot;)
plt.legend()
plt.savefig(f&quot;{output}/1d_profile_inner.svg&quot;, bbox_inches=&quot;tight&quot;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/ml_intro_31_0.png" src="../_images/ml_intro_31_0.png" />
</div>
</div>
</section>
<section id="simple-feed-forward-neural-networks">
<h3>Simple feed-forward neural networks<a class="headerlink" href="#simple-feed-forward-neural-networks" title="Permalink to this headline">#</a></h3>
<p>Deep learning (DL) is a sub-field of ML that focuses on the design, implementation, and optimization of deep neural networks. Neural networks form a class of parametrized functions characterized by great approximation capabilities, especially if high-dimensional mappings from features to labels are required. The functional form of neural networks is inspired by the <a class="reference external" href="https://en.wikipedia.org/wiki/Perceptron">perceptron</a>, which was the first mathematical approach to explain the working of neurons (nerve cells) in the brain. The building blocks of modern neural networks still have some resemblance with the original perceptron, but many modifications have been introduced. These modifications are largely driven by empirical observations and mathematical intuition. In this lecture, we introduce the mathematical form of relatively simple feed-forward neural networks with fully connected layers and use them as a black box function approximation tool. In the next lecture, we learn more about the inner workings of neural networks.</p>
<p>The picture below depicts a feed-forward neural network with its typical components: input and output layers, hidden layers, neurons with activations, bias units, and connections between these components.</p>
<img alt="../_images/example_nn.png" src="../_images/example_nn.png" />
<p>In the input layer, one neuron is reserved for each possible feature <span class="math notranslate nohighlight">\(x_i\)</span> of the feature vector <span class="math notranslate nohighlight">\(\mathbf{x} = \left[x_1, x_2, ..., x_{N_f}\right]^T\)</span>, where <span class="math notranslate nohighlight">\(N_f\)</span> is the number of features. The network sketched above has two neurons for two input features, so <span class="math notranslate nohighlight">\(N_f = 2\)</span>. Considering the test case described in the previous section, the two input features <span class="math notranslate nohighlight">\(x_1\)</span> and <span class="math notranslate nohighlight">\(x_2\)</span> would be the normalized channel height and the Reynolds number, and the single output would be the normalized streamwise velocity. The connections between the input and the first hidden layer represent free parameters, also called weights. If each neuron of one layer is connected with each neuron of the consecutive layer, the layers are said to be <em>fully connected</em>. Fully connected layers are part of almost any modern neural network architecture. In every neuron <span class="math notranslate nohighlight">\(j\)</span> of a hidden layer <span class="math notranslate nohighlight">\(l\)</span>, a weighted sum <span class="math notranslate nohighlight">\(z_j^l\)</span> of all <span class="math notranslate nohighlight">\(N_{neu}^{l-1}\)</span> neurons (features) of the previous layer <span class="math notranslate nohighlight">\(l-1\)</span> is computed:
$<span class="math notranslate nohighlight">\(
  z_j^l\left(\mathbf{x}^{l-1}\right) = \sum\limits_{i=1}^{N_{neu}^{l-1}} w_{ji}^{l-1} x_i^{l-1} + b_j^{l-1}.
\)</span><span class="math notranslate nohighlight">\(
The coefficients \)</span>w_{ij}<span class="math notranslate nohighlight">\( of weight matrix \)</span>\mathbf{W}<span class="math notranslate nohighlight">\( are represented by the lines connecting pairs of neurons in the sketch above. \)</span>b_j<span class="math notranslate nohighlight">\( is the bias unit for the \)</span>j<span class="math notranslate nohighlight">\(th neuron in the next layer. In vector-matrix notation, we can write the above as:
\)</span><span class="math notranslate nohighlight">\(
  \mathbf{z}_l = \mathbf{W}_{l-1}^T \mathbf{x}_{l-1} + \mathbf{b}_{l-1},
\)</span><span class="math notranslate nohighlight">\(
where \)</span>\mathbf{z}<em>l<span class="math notranslate nohighlight">\( and \)</span>\mathbf{b}</em>{l-1}<span class="math notranslate nohighlight">\( are a vector of length \)</span>N_{neu}^{l}<span class="math notranslate nohighlight">\(, \)</span>\mathbf{x}<em>{l-1}<span class="math notranslate nohighlight">\( is a vectors of length \)</span>N</em>{neu}^{l-1}<span class="math notranslate nohighlight">\(, and \)</span>\mathbf{W}<em>{l-1}<span class="math notranslate nohighlight">\( is a matrix of shape \)</span>N</em>{neu}^{l-1}\times N_{neu}^l<span class="math notranslate nohighlight">\(. To increase the network's ability of approximating complex functions, the weighted input must be transformed by a non-linear function. Otherwise, the resulting approximating would remain linear with respect to the inputs regardless of the amount of added layers. Motivated by the biological roots of the approach, the non-linear transformation function \)</span>a(z)<span class="math notranslate nohighlight">\( is commonly called activation function. Typical activation functions will be covered further down in this notebook. The weighted sum of the inputs combined with the activation function results in the inputs (features) of the next layer. Therefore, one could interpret the activation's output as new features \)</span>x_j^l<span class="math notranslate nohighlight">\(:
\)</span><span class="math notranslate nohighlight">\(
  \mathbf{x}_l = a_l(\mathbf{z}_l) = a_l(\mathbf{W}_{l-1}^T\mathbf{x}_{l-1}+\mathbf{b}_{l-1}).
\)</span><span class="math notranslate nohighlight">\(
The length of the new feature vector corresponds to \)</span>N_{neu}^l<span class="math notranslate nohighlight">\(. Note that the activation function gets a lower script \)</span>l<span class="math notranslate nohighlight">\( to indicate that different activation functions may be used in different layers. All networks created and trained in this lecture employ the same activation functions in all hidden layers but may use an application-specific activation for the output layer. In a general regression task, it is likely that the last activation function is linear, i.e., an identity mapping (\)</span>a(z) = z<span class="math notranslate nohighlight">\(). Following the notation introduced above, we can express a fully-connected feed-forward neural network with two hidden layers and linear (no) activation for the output as:
\)</span><span class="math notranslate nohighlight">\(
  f_\theta(\mathbf{x}) = \mathbf{W}_2^T a_1(\mathbf{W}_1^T a_0(\mathbf{W}_0^T\mathbf{x} + \mathbf{b}_0) + \mathbf{b}_1) + \mathbf{b}_2,
\)</span><span class="math notranslate nohighlight">\(
where \)</span>\theta<span class="math notranslate nohighlight">\( represents all the networks tunable parameters contained in the weight matrices and bias units. The re-combination of the feature vector in each one of the network's layers may be written as a repeated function composition \)</span>f(g(x)) = f\circ g(x)<span class="math notranslate nohighlight">\(. Abbreviating the transformation in a single layer \)</span>l<span class="math notranslate nohighlight">\( as \)</span>m_l(\mathbf{x}<em>l)<span class="math notranslate nohighlight">\(, the full network \)</span>f</em>{\theta}(\mathbf{x})<span class="math notranslate nohighlight">\( may be expressed as:
\)</span><span class="math notranslate nohighlight">\(
  f_{\theta}(\mathbf{x}) = m_{N_L} \circ m_{N_{L-1}}\circ ... \circ m_0 (\mathbf{x}),
\)</span><span class="math notranslate nohighlight">\(
where \)</span>\mathbf{x}<span class="math notranslate nohighlight">\( is the original feature vector provided by the input layer and \)</span>N_L<span class="math notranslate nohighlight">\( is the overall number of layers. Evaluating the model for a concrete feature vector \)</span>\mathbf{x}_i<span class="math notranslate nohighlight">\(, a so-called *forward pass*, yields a prediction, typically denoted by \)</span>\hat{\mathbf{y}}_i<span class="math notranslate nohighlight">\(:
\)</span><span class="math notranslate nohighlight">\(
  \hat{\mathbf{y}}_i = f_{\theta}(\mathbf{x}_i).
\)</span><span class="math notranslate nohighlight">\(
Training a neural networks means optimizing its free parameters such that all predictions \)</span>\hat{\mathbf{y}}_i<span class="math notranslate nohighlight">\( match the true labels \)</span>\mathbf{y}_i$ closely. The precise formulation and implementation of the optimization problem follows in the next sections.</p>
<p>The define the network structure discussed before, we can employ <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Linear.html">Linear</a> modules, <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.ReLU.html?highlight=relu#torch.nn.ReLU">ReLU</a> activations, and wrap the layers in a <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Sequential.html?highlight=sequential#torch.nn.Sequential">Sequential</a> container, which forwards the output from one layer to the next. Making predictions works by calling the sequential container like a function.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>n_in, n_out = 2, 1
n_neurons = 20
simple_network = pt.nn.Sequential(
    pt.nn.Linear(n_in, n_neurons),
    pt.nn.ReLU(),
    pt.nn.Linear(n_neurons, n_neurons),
    pt.nn.ReLU(),
    pt.nn.Linear(n_neurons, n_out)
)
example_input = pt.rand(n_in)
simple_network(example_input)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>tensor([-0.0420], grad_fn=&lt;AddBackward0&gt;)
</pre></div>
</div>
</div>
</div>
</section>
<section id="preparing-the-datasets">
<h3>Preparing the datasets<a class="headerlink" href="#preparing-the-datasets" title="Permalink to this headline">#</a></h3>
<p>PyTorch comes with several functions and classes that facilitate the creation of datasets. These abstractions are bundled the the subpackage <code class="docutils literal notranslate"><span class="pre">torch.utils.data</span></code>. As a first step, we reshape our data and wrap the features and labels in a <a class="reference external" href="https://pytorch.org/docs/stable/data.html#torch.utils.data.TensorDataset">TensorDataset</a>. <code class="docutils literal notranslate"><span class="pre">TensorDatasets</span></code> are special in that the entire data must fit into memory. Keeping the data in memory avoids the relatively slow loading from the hard disk. On the other hand, the size of the dataset is limited by the available memory. For larger datasets, PyTorch provides a general <a class="reference external" href="https://pytorch.org/docs/stable/data.html#torch.utils.data.Dataset">Dataset</a> class, which prefetches data from disk to reduce waiting times during training.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">TensorDataset</span></code> constructor expects feature and label tensors as input. Currently, we have the distance normal to the wall, the Reynolds numbers, and the velocity profiles in separate data structures. However, the data structure needed to train a model <span class="math notranslate nohighlight">\(\tilde{u}_x = f_\theta(\tilde{y}, Re)\)</span> looks as follows:</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="text-align:center head"><p><span class="math notranslate nohighlight">\(\tilde{u}_x\)</span></p></th>
<th class="text-align:center head"><p><span class="math notranslate nohighlight">\(\tilde{y}\)</span></p></th>
<th class="text-align:center head"><p><span class="math notranslate nohighlight">\(Re\)</span></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-align:center"><p><span class="math notranslate nohighlight">\(0.131\)</span></p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(0.0001\)</span></p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(98362\)</span></p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p><span class="math notranslate nohighlight">\(0.201\)</span></p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(0.0002\)</span></p></td>
<td class="text-align:center"><p><span class="math notranslate nohighlight">\(98362\)</span></p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p>…</p></td>
<td class="text-align:center"><p>…</p></td>
<td class="text-align:center"><p>…</p></td>
</tr>
</tbody>
</table>
<p>The order of the columns is arbitrary and we could also separate the label <span class="math notranslate nohighlight">\(\tilde{u}_x\)</span> from the two features <span class="math notranslate nohighlight">\(\tilde{y}\)</span> and <span class="math notranslate nohighlight">\(Re\)</span>. For <span class="math notranslate nohighlight">\(N_r\)</span> selected Reynolds numbers/profiles and <span class="math notranslate nohighlight">\(N_y\)</span> points per profile, the resulting tensor should have <span class="math notranslate nohighlight">\(N_r\times N_y\)</span> rows and three columns. The <code class="docutils literal notranslate"><span class="pre">reshape_data</span></code> function below creates the required format.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def reshape_data(u_x_norm: pt.Tensor, y_norm: pt.Tensor, Re: pt.Tensor) -&gt; pt.Tensor:
    &quot;&quot;&quot;Create feature and label vectors.

    :param u_x_norm: velocity profiles normalized with Ubar; first zeroth dimension
     corresponds to the distance y; first dimension corresponds to the Reynolds number
    :type u_x_norm: pt.Tensor
    :param y_norm: distance from the wall normalized by twice the channel hight;
        ordered from lowest to largest
    :type y_norm: pt.Tensor
    :param Re: Reynolds number based on average velocity, twice the channel height,
        and kinematic viscosity
    :type Re: pt.Tensor
    :return: data suitable for training; if there are Ny points normal to
        the wall and Nr different Reynolds numbers, the resulting tensor
        has the shape (Ny*Nr, 3)
    :rtype: pt.Tensor
    &quot;&quot;&quot;
    data = pt.zeros((u_x_norm.shape[0]*u_x_norm.shape[1], 3))
    for i in range(u_x_norm.shape[1]):
        start, end = i*u_x_norm.shape[0], (i+1)*u_x_norm.shape[0]
        data[start:end, 0] = u_x_norm[:, i]
        data[start:end, 1] = y_norm
        data[start:end, 2] = Re[i]
    return data
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># normalize velocity and wall normal distance
u_x_norm = u_x / Ubar.max()
y_norm = y/(2*delta)
# reshape data
reshaped_data = reshape_data(u_x_norm, y_norm, Re)
# create a TensorDataset
dataset = pt.utils.data.TensorDataset(reshaped_data[:, 1:], reshaped_data[:, 0])
# the dataset supports indexing; dataset[0] returns the 0th feature-label-pair
dataset[0]
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(tensor([3.3002e-05, 1.3430e+04]), tensor(0.0002))
</pre></div>
</div>
</div>
</div>
<p>Next, we split the data into three parts. One part contains most of the data and will be used for optimizing the network’s free parameters. The other two parts are significantly smaller and will be used to evaluate the training process. One of the smaller parts is meant to provide feedback during the optimization while the other one is only evaluated after the training is done. In summary, the data is split into:</p>
<ul class="simple">
<li><p><strong>training data</strong>: optimization of model parameters</p></li>
<li><p><strong>validation data</strong>: model evaluation during training</p></li>
<li><p><strong>testing data</strong>: final model evaluation after training</p></li>
</ul>
<p>Note that the naming of testing and validation data is somewhat arbitrary and ML practitioners may use the terms interchangeably. For the low-dimensional problem considered here, we can inspect the model’s properties by means of standard visualization techniques. However, as the problems become high-dimensional, the split is essential to assess the model’s characteristics. More about the assessment follows in a dedicated section of this notebook.</p>
<p>PyTorch’s <a class="reference external" href="https://pytorch.org/docs/stable/data.html#torch.utils.data.random_split">random_split</a> divides a dataset according to user-defined sizes. The code below creates three datasets, where the first dataset contains roughly <span class="math notranslate nohighlight">\(70\%\)</span> of the data and the remaining features-label-pairs are equally distributed in validation and testing data.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>train_size = int(0.7*len(dataset))
val_size = int(0.15*len(dataset))
test_size = len(dataset) - train_size - val_size
train_dataset, val_dataset, test_dataset = pt.utils.data.random_split(dataset, (train_size, val_size, test_size))
len(dataset), len(train_dataset), len(val_dataset), len(test_dataset)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(3200, 2240, 480, 480)
</pre></div>
</div>
</div>
</div>
<p>The splitting approach employed before is a good option for general datasets. However, our data comes with a certain structure related to the fact that groups of feature-labels-pairs belong to a single profile/simulation. With the current split, validation and testing data won’t be very different from the training data due the high mesh resolution in <span class="math notranslate nohighlight">\(y\)</span> direction. What we rather want to test with the additional two datasets in the performance at unknown Reynolds numbers. We can build this stricter evaluation approach by splitting the datasets based on individual velocity profiles. The randomly select the profiles/simulations, we use the <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.multinomial.html">multinomial</a> probability distribution. The multinomial probability distribution draws samples from discrete events (categories) according to a given list of probabilities for each category. When sampling, the probability distribution returns the indices of the drawn categories. In our case, there are 16 different categories, one for each Reynolds number. The probability tensor is initialized with ones, meaning that every category has the same chance of being drawn. We then draw ten Reynolds numbers for training, set the corresponding indices of the probability tensor to zero, and repeat the process for validation and testing data. It is important to note that, by the implementation’s defaults, no category will be drawn twice because the <code class="docutils literal notranslate"><span class="pre">replacement</span></code> variable is set to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>A final constrained we apply to the splitting strategy concerns the minimum and maximum Reynolds numbers. We don’t want the model to extrapolate, which is in general something to avoid. Therefore, we enforce the lowest and highest <span class="math notranslate nohighlight">\(Re\)</span> data to be in the training set. This task is easy since the <code class="docutils literal notranslate"><span class="pre">Re</span></code> tensor is already sorted.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>Re
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>tensor([13429.9990, 20390.0000, 24930.0000, 27810.0020, 33960.0000, 40190.0000,
        44320.0000, 51620.0000, 55090.0000, 63880.0039, 68020.0000, 76740.0000,
        80510.0000, 84810.0000, 93240.0000, 96340.0000])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># select two snapshots for testing
n_Re = len(Re)
probs = pt.ones(u_x.shape[-1])
probs[0] = 0.0
probs[-1] = 0.0
train_size, val_size, test_size = 8, 3, 3
test_idx = pt.multinomial(probs, test_size)
probs[test_idx] = 0.0
val_idx = pt.multinomial(probs, val_size)
probs[val_idx] = 0.0
train_idx = pt.multinomial(probs, train_size)
train_idx = pt.cat((train_idx, pt.tensor([0, n_Re-1], dtype=pt.int64)))
print(&quot;Re for testing: &quot;, Re[test_idx])
print(&quot;Re for validation: &quot;, Re[val_idx])
print(&quot;Re for training: &quot;, Re[train_idx])
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Re for testing:  tensor([80510., 40190., 20390.])
Re for validation:  tensor([63880.0039, 51620.0000, 76740.0000])
Re for training:  tensor([93240.0000, 55090.0000, 27810.0020, 24930.0000, 33960.0000, 68020.0000,
        84810.0000, 44320.0000, 13429.9990, 96340.0000])
</pre></div>
</div>
</div>
</div>
<p>Before creating the final datasets, we need to normalize the data to avoid roundoff errors. The <code class="docutils literal notranslate"><span class="pre">MinMaxScaler</span></code> class defined below wraps around the minimum/maximum values and scaling/rescaling functions. We also created a dataset without normalization to show the importance of feature normalization later on. Note that we create the scaler objects only based on the training data, because we don’t want to use any information from the test data during training.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>class MinMaxScaler(object):
    &quot;&quot;&quot;Class to scale/re-scale data to the range [-1, 1] and back.
    &quot;&quot;&quot;
    def __init__(self):
        self.min = None
        self.max = None
        self.initialized = False

    def fit(self, data):
        self.min = data.min(dim=0).values
        self.max = data.max(dim=0).values
        self.initialized = True
        return self

    def scale(self, data):
        assert self.initialized
        data_norm = (data - self.min) / (self.max - self.min)
        return 2.0*data_norm - 1.0

    def rescale(self, data_norm):
        assert self.initialized
        data = (data_norm + 1.0) * 0.5
        return data * (self.max - self.min) + self.min
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>train_tensor = reshape_data(u_x_norm[:, train_idx], y_norm, Re[train_idx])
val_tensor = reshape_data(u_x_norm[:, val_idx], y_norm, Re[val_idx])
test_tensor = reshape_data(u_x_norm[:, test_idx], y_norm, Re[test_idx])
feature_scaler = MinMaxScaler().fit(train_tensor[:, 1:])
label_scaler = MinMaxScaler().fit(train_tensor[:, 0])
train_dataset = pt.utils.data.TensorDataset(
    feature_scaler.scale(train_tensor[:, 1:]), label_scaler.scale(train_tensor[:, 0]).unsqueeze(-1)
)
val_dataset = pt.utils.data.TensorDataset(
    feature_scaler.scale(val_tensor[:, 1:]), label_scaler.scale(val_tensor[:, 0]).unsqueeze(-1)
)
test_dataset = pt.utils.data.TensorDataset(
    feature_scaler.scale(test_tensor[:, 1:]), label_scaler.scale(test_tensor[:, 0]).unsqueeze(-1)
)
train_dataset_raw = pt.utils.data.TensorDataset(train_tensor[:, 1:], train_tensor[:, 0].unsqueeze(-1))
val_dataset_raw = pt.utils.data.TensorDataset(val_tensor[:, 1:], val_tensor[:, 0].unsqueeze(-1))
test_dataset_raw = pt.utils.data.TensorDataset(test_tensor[:, 1:], test_tensor[:, 0].unsqueeze(-1))
len(train_dataset), len(val_dataset), len(test_dataset)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(2000, 600, 600)
</pre></div>
</div>
</div>
</div>
<p>There is one final useful abstraction for datasets, namely a <a class="reference external" href="https://pytorch.org/docs/stable/data.html#torch.utils.data.DataLoader">Dataloader</a>. As you will see in the next section, it is useful loop over the datasets in small junks of feature-label-pairs, so-called batches. The dataloader takes a dataset as input and allows us to loop over such non-overlapping batches (non-overlapping means that a single feature-label-pair cannot be contained in multiple batches). Moreover, we can let the dataloader shuffle the batches such that the batches are different each time we loop over the dataset (we don’t want the order of the data in the set to affect the training).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>train_loader = pt.utils.data.DataLoader(train_dataset, batch_size=int(len(train_dataset) / 4), shuffle=True)
for features, labels in train_loader:
    print(features.shape, labels.shape)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>torch.Size([500, 2]) torch.Size([500, 1])
torch.Size([500, 2]) torch.Size([500, 1])
torch.Size([500, 2]) torch.Size([500, 1])
torch.Size([500, 2]) torch.Size([500, 1])
</pre></div>
</div>
</div>
</div>
</section>
<section id="generic-training-loop">
<h3>Generic training loop<a class="headerlink" href="#generic-training-loop" title="Permalink to this headline">#</a></h3>
<p>To simplify notation, we define a long vector <span class="math notranslate nohighlight">\(\mathbf{\theta}\)</span> holding all of the network’s parameters (weights). For optimizing the wights, we need a metric expressing how good the model’s prediction is. The most common metric used for regression problems is the mean squared error (MSE), also referred to as <span class="math notranslate nohighlight">\(L_2\)</span> norm/loss. For a set of <span class="math notranslate nohighlight">\(N\)</span> generic pairs of feature vectors <span class="math notranslate nohighlight">\(\mathbf{x}_i\)</span> and label vectors <span class="math notranslate nohighlight">\(\mathbf{y}_i\)</span>, the <span class="math notranslate nohighlight">\(L_2\)</span> loss is defined as:
$<span class="math notranslate nohighlight">\(
  L_2(\mathbf{\mathbf{\theta}}) = \frac{1}{N}\sum\limits_{i=1}^N \left( \mathbf{y}_i - f_{\mathbf{\theta}}(\mathbf{x}_i) \right)^2,
\)</span><span class="math notranslate nohighlight">\(
where \)</span>f_{\mathbf{\theta}}(\mathbf{x})<span class="math notranslate nohighlight">\( is the model with weights \)</span>\mathbf{\theta}<span class="math notranslate nohighlight">\( and \)</span> \hat{\mathbf{y}}<em>i = f</em>{\mathbf{\theta}}(\mathbf{x}_i) <span class="math notranslate nohighlight">\( is the prediction for the \)</span>i<span class="math notranslate nohighlight">\(th feature vector instance. The goal of the parameter optimization/training is to find the parameter configuration \)</span>\mathbf{\theta}^\ast<span class="math notranslate nohighlight">\( yielding the minimal loss:
\)</span><span class="math notranslate nohighlight">\(
  \mathbf{\theta}^\ast = \underset{\mathbf{\theta}}{\mathrm{argmin}} L_2 (\mathbf{\theta}).
\)</span>$</p>
<p>The most common update rule for the model weights is called gradient decent. The idea is simple: we compute the gradient of the loss function with respect to the weights and make a small adjustment of the weights in the negative gradient direction:
$<span class="math notranslate nohighlight">\(
  \mathbf{\theta}_{n+1} = \mathbf{\theta}_n - \lambda_0 \frac{\mathrm{d}L}{\mathrm{d}\mathbf{\theta}},
\)</span><span class="math notranslate nohighlight">\(
where \)</span>n<span class="math notranslate nohighlight">\( indicate the current iteration, \)</span>\lambda_0<span class="math notranslate nohighlight">\( is the learning rate, and \)</span>L<span class="math notranslate nohighlight">\( represents a generic loss function. Modern training approaches use a more advanced version of gradient decent that may be expressed as:
\)</span><span class="math notranslate nohighlight">\(
  \mathbf{\theta}_{n+1} = \mathbf{\theta}_n - g\left(\lambda_0,\frac{\mathrm{d}L}{\mathrm{d}\mathbf{\theta}}\right),
\)</span><span class="math notranslate nohighlight">\(
where \)</span>g$ is a functional abstraction of techniques like momentum, learning rate scheduling, and gradient clipping. The first two of these techniques are introduced and implemented later on in this notebook.</p>
<p>In general, the loss function of a neural network may be non-linear and non-convex. Therefore, the loss values do not always decreases monotonically. If we perform a fixed number of optimization epochs/iterations, the final parameter configuration is not necessarily the best one. A simple strategy to keep the best model is to compare the current loss value against the best loss values encountered during the training. If a new best loss is reached, a snapshot of the model is saved. After the training, we can load and evaluate only the best model.</p>
<p>The code block below implements a relatively comprehensive training loop, which will be used for almost all examples in the course involving neural networks. A few important features of the <code class="docutils literal notranslate"><span class="pre">train_model</span></code> function are:</p>
<ul class="simple">
<li><p>evaluation of user-defined metric on training, validation, and test data</p></li>
<li><p>monitoring of training performance in terms of loss and training time</p></li>
<li><p>saving of checkpoints; the checkpoints allow to restart the training, e.g., after an unexpected failure</p></li>
<li><p>saving of the best model based on the training or validation loss</p></li>
<li><p>learning rate adjustment based on a user-defined scheduler</p></li>
</ul>
<p>Only some of these features are explored in this notebook.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def run_epoch(
    model: pt.nn.Module,
    optimizer: pt.optim.Optimizer,
    data_loader: pt.utils.data.DataLoader,
    loss_func: pt.nn.Module,
    device: str,
    results: dict,
    score_funcs: dict,
    prefix: str
    ) -&gt; float:
    &quot;&quot;&quot;Perform one optimizing step on a model.

    This loop is a slightly modified version of &#39;run_epoch&#39;
    provided in chapter 5 of &#39;Inside Deep Learning&#39; by Edward Raff;
    refer to:
    https://github.com/EdwardRaff/Inside-Deep-Learning/blob/main/idlmam.py
    &quot;&quot;&quot;

    # keeping track of loss, predictions, and time
    running_loss, labels_true, labels_pred = [], [], []
    start_time = time()

    # loop over all batches
    for features, labels in data_loader:
        features, labels = features.to(device), labels.to(device)
        pred = model(features)
        loss = loss_func(labels, pred)
        if model.training:
            loss.backward()
            optimizer.step()
            optimizer.zero_grad()
        running_loss.append(loss.item())

        # the dataset might get shuffled in the next loop
        if len(score_funcs) &gt; 0:
            labels_true.extend(labels.detach().cpu().tolist())
            labels_pred.extend(pred.detach().cpu().tolist())

    # keep track of performance
    results[f&quot;{prefix}_loss&quot;].append(sum(running_loss) / len(running_loss))
    for name, func in score_funcs.items():
        results[f&quot;{prefix}_{name}&quot;].append(func(labels_true, labels_pred))

    return time() - start_time


def train_model(
    model: pt.nn.Module,
    loss_func: pt.nn.Module,
    train_loader: pt.utils.data.DataLoader,
    val_loader: pt.utils.data.DataLoader = None,
    test_loader: pt.utils.data.DataLoader = None,
    score_funcs: dict = {},
    epochs: int = 100,
    device: str = &quot;cpu&quot;,
    checkpoint_file: str = None,
    log_all: bool = False,
    lr_schedule: pt.optim.lr_scheduler._LRScheduler = None,
    optimizer: pt.optim.Optimizer = None) -&gt; pd.DataFrame:
    &quot;&quot;&quot;Perform one optimizing step on a model.

    This function is a slightly modified version of &#39;train_network&#39;
    provided in chapter 5 of &#39;Inside Deep Learning&#39; by Edward Raff;
    refer to:
    https://github.com/EdwardRaff/Inside-Deep-Learning/blob/main/idlmam.py
    &quot;&quot;&quot;

    # dictionary for keeping track of training performance
    results = defaultdict(list)
    best_loss = float(&quot;inf&quot;)
    ref_loss = &quot;train_loss&quot; if val_loader is None else &quot;val_loss&quot;

    # use AdamW as default optimizer if none specified
    delete_optimizer = False
    if optimizer is None:
        optimizer = pt.optim.AdamW(model.parameters())
        delete_optimizer = True

    total_train_time = 0.0
    model.to(device)
    for e in range(epochs):
        # model update
        model = model.train()
        total_train_time += run_epoch(
            model, optimizer, train_loader, loss_func, device,
            results, score_funcs, prefix=&quot;train&quot;
        )
        results[&quot;epoch&quot;].append(e)
        results[&quot;total_time&quot;].append(total_train_time)
        message = f&quot;Training loss: {results[&#39;train_loss&#39;][-1]:2.6e}&quot;


        # validation dataset
        if val_loader is not None:
            model = model.eval()
            with pt.no_grad():
                _ = run_epoch(
                    model, optimizer, val_loader, loss_func, device,
                    results, score_funcs, prefix=&quot;val&quot;
                )
            message += f&quot;; Validation loss: {results[&#39;val_loss&#39;][-1]:2.6e}&quot;

        # update of learning rate
        if lr_schedule is not None:
            if isinstance(lr_schedule, pt.optim.lr_scheduler.ReduceLROnPlateau):
                lr_schedule.step(results[&quot;val_loss&quot;][-1])
            else:
                lr_schedule.step()

        # test dataset
        if test_loader is not None:
            model = model.eval()
            with pt.no_grad():
                _ = run_epoch(
                    model, optimizer, test_loader, loss_func, device,
                    results, score_funcs, prefix=&quot;test&quot;
                )
            message += f&quot;; Test loss: {results[&#39;test_loss&#39;][-1]:2.6e}&quot;

        # save checkpoint
        if checkpoint_file is not None:
            suffix = f&quot;_epoch_{e}&quot; if log_all else &quot;&quot;
            pt.save(
                {
                    &quot;epoch&quot; : e,
                    &quot;model_state_dict&quot; : model.state_dict(),
                    &quot;optimizer_state_dict&quot;: optimizer.state_dict(),
                    &quot;results&quot; : results
                }, checkpoint_file + suffix
            )
            latest_loss = results[ref_loss][-1]
            if latest_loss &lt; best_loss:
                best_loss = latest_loss
                copy(checkpoint_file + suffix, checkpoint_file + &quot;_best&quot;)
                

        print(
            &quot;\r&quot;, f&quot;Epoch {e:4d}/{epochs - 1} - &quot; + message, end=&quot;&quot;
        )

    # if the optimizer was created in the training loop,
    # delete if to avoid unwanted side effects
    if delete_optimizer:
        del optimizer

    return pd.DataFrame.from_dict(results)
</pre></div>
</div>
</div>
</div>
<p>The function below simplifies the construction of simple fully-connected neural networks with a variable of hidden layers.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def create_simple_network(n_in: int, n_out: int, n_neurons: int,
    n_hidden: int, activation: pt.nn.Module) -&gt; pt.nn.Sequential:
    layers = [
        pt.nn.Linear(n_in, n_neurons),
        activation()
    ]
    for _ in range(n_hidden):
        layers.append(pt.nn.Linear(n_neurons, n_neurons))
        layers.append(activation())
    layers.append(pt.nn.Linear(n_neurons, n_out))
    return pt.nn.Sequential(*layers)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>model_0_base = create_simple_network(2, 1, 50, 2, pt.nn.ReLU)
train_loader = pt.utils.data.DataLoader(train_dataset, batch_size=len(train_dataset), shuffle=True)
val_loader = pt.utils.data.DataLoader(val_dataset, batch_size=len(val_dataset))
test_loader = pt.utils.data.DataLoader(test_dataset, batch_size=len(test_dataset))
score_funcs = {
    &quot;Lmax&quot; : metrics.max_error,
    &quot;L1&quot; : metrics.mean_absolute_error,
    &quot;R2&quot; : metrics.r2_score
}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>model_0 = deepcopy(model_0_base)
results_0 = train_model(
    model_0,
    pt.nn.MSELoss(),
    train_loader, val_loader, test_loader,
    score_funcs,
    500,
    optimizer=pt.optim.AdamW(model_0.parameters(), lr=0.001)
)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> Epoch  499/499 - Training loss: 3.703182e-03; Validation loss: 3.137902e-03; Test loss: 2.313281e-03
</pre></div>
</div>
</div>
</div>
<p>Plotting the MSE loss indicates a steady learning. With more epochs, the loss is likely to drop further. Moreover, the loss computed on validation and test data shows a similar trend as on the training data. Therefore, the model is most likely not overfitting (memorizing) the training data.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.plot(results_0[&quot;epoch&quot;], results_0[&quot;train_loss&quot;], lw=1, label=&quot;training&quot;)
plt.plot(results_0[&quot;epoch&quot;], results_0[&quot;val_loss&quot;], lw=1, label=&quot;validation&quot;)
plt.plot(results_0[&quot;epoch&quot;], results_0[&quot;test_loss&quot;], lw=1, label=&quot;testing&quot;)
plt.yscale(&quot;log&quot;)
plt.xlim(0, 500)
plt.xlabel(&quot;epoch&quot;)
plt.ylabel(&quot;MSE&quot;)
plt.legend()
plt.savefig(join(output, &quot;loss_lecture_4_model_0.svg&quot;), bbox_inches=&quot;tight&quot;)
plt.show()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/ml_intro_55_0.png" src="../_images/ml_intro_55_0.png" />
</div>
</div>
<p>Normalizing the data is enormously important to mitigate the influence of roundoff errors. To demonstrate the impact of normalization, we repeat the training with the unscaled data. The enormous difference in the order of magnitude between <span class="math notranslate nohighlight">\(\tilde{y}\)</span> and <span class="math notranslate nohighlight">\(Re\)</span> inhibits the learning after about 150 epochs.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>train_loader_raw = pt.utils.data.DataLoader(train_dataset_raw, batch_size=len(train_dataset_raw), shuffle=True)
val_loader_raw = pt.utils.data.DataLoader(val_dataset_raw, batch_size=len(val_dataset_raw))
test_loader_raw = pt.utils.data.DataLoader(test_dataset_raw, batch_size=len(test_dataset_raw))
model_0_raw = deepcopy(model_0_base)
results_0_raw = train_model(
    model_0_raw,
    pt.nn.MSELoss(),
    train_loader_raw, val_loader_raw, test_loader_raw,
    epochs=500,
    optimizer=pt.optim.AdamW(model_0_raw.parameters(), lr=0.001)
)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> Epoch  499/499 - Training loss: 3.648483e-02; Validation loss: 3.476597e-02; Test loss: 2.301314e-02
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.plot(results_0_raw[&quot;epoch&quot;], results_0_raw[&quot;train_loss&quot;], lw=1, label=&quot;training&quot;)
plt.plot(results_0_raw[&quot;epoch&quot;], results_0_raw[&quot;val_loss&quot;], lw=1, label=&quot;validation&quot;)
plt.plot(results_0_raw[&quot;epoch&quot;], results_0_raw[&quot;test_loss&quot;], lw=1, label=&quot;testing&quot;)
plt.yscale(&quot;log&quot;)
plt.xlim(0, 500)
plt.xlabel(&quot;epoch&quot;)
plt.ylabel(&quot;MSE&quot;)
plt.legend()
plt.savefig(join(output, &quot;loss_lecture_4_model_0_raw.svg&quot;), bbox_inches=&quot;tight&quot;)
plt.show()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/ml_intro_58_0.png" src="../_images/ml_intro_58_0.png" />
</div>
</div>
<p>Comparing the prediction of the first model against the true labels shows that the model reflect the trend of with respect to the Reynolds number already quite well. Some fluctuations of the predicted profiles around the true ones are visible.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def make_prediction(model, data, feature_scaler, label_scaler):
    return label_scaler.rescale(
        model(feature_scaler.scale(data)).squeeze().detach()
    )
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>pred_train_0 = make_prediction(model_0, train_tensor[:, 1:], feature_scaler, label_scaler)
pred_val_0 = make_prediction(model_0, val_tensor[:, 1:], feature_scaler, label_scaler)
pred_test_0 = make_prediction(model_0, test_tensor[:, 1:], feature_scaler, label_scaler)


n_points = len(y)
for i in range(len(Re)):
    plt.plot(u_x[:, i]/Ubar.max(), y/(2*delta), ls=&quot;-&quot;, c=&quot;k&quot;)
plt.scatter(pred_train_0, train_tensor[:, 1], s=1, c=&quot;C0&quot;, zorder=6, label=&quot;training&quot;)
plt.scatter(pred_val_0, val_tensor[:, 1], s=1, c=&quot;C1&quot;, zorder=6, label=&quot;validation&quot;)
plt.scatter(pred_test_0, test_tensor[:, 1], s=1, c=&quot;C2&quot;, zorder=6, label=&quot;testing&quot;)
plt.xlabel(r&quot;$\tilde{u}_x$&quot;)
plt.ylabel(r&quot;$\tilde{y}$&quot;)
plt.xlim(0, 1.2)
plt.ylim(-0.01, 0.5)
plt.legend()
plt.savefig(join(output, &quot;prediction_lecture_4_model_0.svg&quot;), bbox_inches=&quot;tight&quot;)
plt.show()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/ml_intro_61_0.png" src="../_images/ml_intro_61_0.png" />
</div>
</div>
</section>
<section id="training-with-batches-of-data">
<h3>Training with batches of data<a class="headerlink" href="#training-with-batches-of-data" title="Permalink to this headline">#</a></h3>
<p>So far, we used the entire training dataset at once to update the weights in a single epoch. Instead, we can also create small junks of data and update the weights based on each individual junk. This idea is called batch training and leads many more updates within a single epoch. Moreover, computing the gradient based on a subset of the data sometimes helps to overcome local minima and reduces the memory requirements of the training. A drawback of decreasing the batch size, i.e., creating smaller junks, is the increased training time because smaller batches don’t allow to exploit parallelization to its full potential.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>batch_sizes = (64, 128, 512, len(train_dataset))
batch_results = []
for bs in batch_sizes:
    model_bs = deepcopy(model_0_base)
    batch_results.append(
        train_model(
            model_bs,
            pt.nn.MSELoss(),
            pt.utils.data.DataLoader(train_dataset, batch_size=bs, shuffle=True),
            epochs=500,
            optimizer=pt.optim.AdamW(model_bs.parameters(), lr=0.001)
        )
    )
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> Epoch  499/499 - Training loss: 3.650685e-03
</pre></div>
</div>
</div>
</div>
<p>In the plot below we see that the loss drops significantly faster for smaller batches and reaches also lower final loss values. However, also the loss fluctuations increase as the gradient prediction becomes more spurious.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>for bs, res in zip(batch_sizes, batch_results):
    plt.plot(res[&quot;epoch&quot;], res[&quot;train_loss&quot;], lw=1, label=f&quot;{bs:d}, T={res[&#39;total_time&#39;].values[-1]:2.2f}s&quot;)

plt.xlabel(&quot;epoch&quot;)
plt.ylabel(&quot;MSE&quot;)
plt.yscale(&quot;log&quot;)
plt.xlim(0, 500)
plt.legend()
plt.savefig(join(output, &quot;batch_size_lecture_4.svg&quot;), bbox_inches=&quot;tight&quot;)
plt.show()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/ml_intro_65_0.png" src="../_images/ml_intro_65_0.png" />
</div>
</div>
</section>
<section id="learning-rate-adjustment">
<h3>Learning rate adjustment<a class="headerlink" href="#learning-rate-adjustment" title="Permalink to this headline">#</a></h3>
<p>One way to counteract oscillations in the training loss is an adjustment of the learning rate. Smaller learning lead to smaller changes in the weights. However, if the learning rate is too small, we may never reach a good optimum or require an excessive amount of epochs/resources. In the learning rate test below, a value of <span class="math notranslate nohighlight">\(\lambda_0 = 5\times 10^{-4}\)</span> yields the best final loss value. Nonetheless, higher learning rates yield a much stronger drop in the initial epochs. Next, we combine the best attributes of low and high learning rates by employing dynamic learning rate adjustment.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>lr_to_test = [1.0e-2, 5.0e-3, 1.0e-3, 5.0e-4, 1.0e-4]
lr_results = []
train_loader = pt.utils.data.DataLoader(train_dataset, batch_size=128, shuffle=True)
for lr in lr_to_test:
    model_lr = deepcopy(model_0_base)
    lr_results.append(
        train_model(
            model_lr,
            pt.nn.MSELoss(),
            train_loader, val_loader, test_loader,
            epochs=500,
            optimizer=pt.optim.AdamW(model_lr.parameters(), lr=lr)
        )
    )
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> Epoch  499/499 - Training loss: 2.593159e-03; Validation loss: 2.350085e-03; Test loss: 2.139329e-03
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>for lr, res in zip(lr_to_test, lr_results):
    plt.plot(res[&quot;epoch&quot;], res[&quot;train_loss&quot;], lw=1, label=f&quot;{lr:1.0e}&quot;)

plt.xlabel(&quot;epoch&quot;)
plt.ylabel(&quot;MSE&quot;)
plt.yscale(&quot;log&quot;)
plt.xlim(0, 500)
plt.legend()
plt.savefig(join(output, &quot;lr_bs128_lecture_4.svg&quot;), bbox_inches=&quot;tight&quot;)
plt.show()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/ml_intro_68_0.png" src="../_images/ml_intro_68_0.png" />
</div>
</div>
<p>In the cells below, several scheduling strategies for the learning rate are compared:</p>
<ul class="simple">
<li><p><strong>const.</strong>: constant learning rate as initialized in the optimizer</p></li>
<li><p><strong>exp. decay:</strong> exponential decay from the initial to the minimum value within a given number of epochs</p></li>
<li><p><strong>step decay:</strong> learning rate reduction every <span class="math notranslate nohighlight">\(S\)</span> steps</p></li>
<li><p><strong>cosine:</strong> oscillatory adjustment of the learning rate around the initial value; might help to overcome local minima</p></li>
<li><p><strong>plateau:</strong> reduce learning rate by a given factor whenever the validation loss did not decrease for <code class="docutils literal notranslate"><span class="pre">patience</span></code> steps</p></li>
</ul>
<p>The stepwise, exponential, and plateau reduction yield improved final loss value, accelerate the learning, and mitigate loss fluctuations towards the end of the training.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>model_exp_decay = deepcopy(model_0_base)
train_loader = pt.utils.data.DataLoader(train_dataset, batch_size=128, shuffle=True)
optimizer = optimizer=pt.optim.AdamW(model_exp_decay.parameters(), lr=0.01)
gamma_exp = (1.0e-4 / 1.0e-2)**(1.0/500)
scheduler = pt.optim.lr_scheduler.ExponentialLR(optimizer=optimizer, gamma=gamma_exp)

results_exp_decay = train_model(
    model_exp_decay,
    pt.nn.MSELoss(),
    train_loader, val_loader, test_loader,
    epochs=500,
    lr_schedule=scheduler,
    optimizer=optimizer
)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> Epoch  499/499 - Training loss: 3.927640e-05; Validation loss: 1.669829e-04; Test loss: 1.406699e-04
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>model_step_decay = deepcopy(model_0_base)
optimizer = optimizer=pt.optim.AdamW(model_step_decay.parameters(), lr=0.01)
gamma_step = 0.3
scheduler = pt.optim.lr_scheduler.StepLR(optimizer=optimizer, step_size=500//4, gamma=gamma_step)

results_step_decay = train_model(
    model_step_decay,
    pt.nn.MSELoss(),
    train_loader, val_loader, test_loader,
    epochs=500,
    lr_schedule=scheduler,
    optimizer=optimizer
)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> Epoch  499/499 - Training loss: 2.291339e-04; Validation loss: 5.352701e-04; Test loss: 5.303427e-04
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>model_cosine = deepcopy(model_0_base)
optimizer = optimizer=pt.optim.AdamW(model_cosine.parameters(), lr=0.001)
scheduler = pt.optim.lr_scheduler.CosineAnnealingLR(optimizer=optimizer, T_max=500//3, eta_min=1.0e-4)

results_cosine = train_model(
    model_cosine,
    pt.nn.MSELoss(),
    train_loader, val_loader, test_loader,
    epochs=500,
    lr_schedule=scheduler,
    optimizer=optimizer
)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> Epoch  499/499 - Training loss: 9.224808e-05; Validation loss: 5.831620e-04; Test loss: 3.860441e-04
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>model_plateau = deepcopy(model_0_base)
optimizer = optimizer=pt.optim.AdamW(model_plateau.parameters(), lr=0.01)
scheduler = pt.optim.lr_scheduler.ReduceLROnPlateau(optimizer=optimizer, mode=&quot;min&quot;, factor=0.5, patience=20, min_lr=1.0e-4)
results_plateau = train_model(
    model_plateau,
    pt.nn.MSELoss(),
    train_loader, val_loader, test_loader,
    epochs=500,
    lr_schedule=scheduler,
    optimizer=optimizer
)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> Epoch  499/499 - Training loss: 7.438762e-05; Validation loss: 5.873441e-04; Test loss: 1.206016e-04
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>scheduler_res = {
    &quot;const.&quot; : lr_results[-2],
    &quot;exp. decay&quot; : results_exp_decay,
    &quot;step decay&quot; : results_step_decay,
    &quot;cosine&quot; : results_cosine,
    &quot;plateau&quot; : results_plateau
}

fig, (ax1, ax2) = plt.subplots(2, figsize=(6, 4), sharex=True, sharey=True)
for key, res in scheduler_res.items():
    ax1.plot(res[&quot;epoch&quot;], res[&quot;train_loss&quot;], lw=1, label=f&quot;{key}&quot;)
    ax2.plot(res[&quot;epoch&quot;], res[&quot;val_loss&quot;], lw=1, label=f&quot;{key}&quot;)

ax1.set_title(&quot;training&quot;)
ax2.set_title(&quot;validation&quot;)
ax2.set_xlabel(&quot;epoch&quot;)
for ax in (ax1, ax2):
    ax.set_ylabel(&quot;MSE&quot;)
    ax.set_yscale(&quot;log&quot;)
ax1.set_xlim(0, 500)
ax1.legend(ncol=3)
plt.savefig(join(output, &quot;lr_scheduler_bs128_lecture_4.svg&quot;), bbox_inches=&quot;tight&quot;)
plt.show()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/ml_intro_74_0.png" src="../_images/ml_intro_74_0.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>for i, (key, res) in enumerate(scheduler_res.items()):
    plt.plot(res[&quot;epoch&quot;], res[&quot;test_loss&quot;], lw=1, label=f&quot;{key}&quot;)

plt.xlabel(&quot;epoch&quot;)
plt.ylabel(&quot;MSE&quot;)
plt.yscale(&quot;log&quot;)
plt.xlim(0, 500)
plt.legend()
plt.title(&quot;test data&quot;)
plt.savefig(join(output, &quot;lr_scheduler_bs128_test_lecture_4.svg&quot;), bbox_inches=&quot;tight&quot;)
plt.show()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/ml_intro_75_0.png" src="../_images/ml_intro_75_0.png" />
</div>
</div>
<p>The prediction below shows improved accuracy and reduced oscillations compared to the first attempt.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>pred_train_pl = make_prediction(model_plateau, train_tensor[:, 1:], feature_scaler, label_scaler)
pred_val_pl = make_prediction(model_plateau, val_tensor[:, 1:], feature_scaler, label_scaler)
pred_test_pl = make_prediction(model_plateau, test_tensor[:, 1:], feature_scaler, label_scaler)


n_points = len(y)
for i in range(len(Re)):
    plt.plot(u_x[:, i]/Ubar.max(), y/(2*delta), ls=&quot;-&quot;, c=&quot;k&quot;)
plt.scatter(pred_train_pl, train_tensor[:, 1], s=1, c=&quot;C0&quot;, zorder=6, label=&quot;training&quot;)
plt.scatter(pred_val_pl, val_tensor[:, 1], s=1, c=&quot;C1&quot;, zorder=6, label=&quot;validation&quot;)
plt.scatter(pred_test_pl, test_tensor[:, 1], s=1, c=&quot;C2&quot;, zorder=6, label=&quot;testing&quot;)
plt.xlabel(r&quot;$\tilde{u}_x$&quot;)
plt.ylabel(r&quot;$\tilde{y}$&quot;)
plt.xlim(0.0, 1.2)
plt.ylim(-0.01, 0.5)
plt.legend()
plt.savefig(join(output, &quot;prediction_lecture_4_model_pl.svg&quot;), bbox_inches=&quot;tight&quot;)
plt.show()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/ml_intro_77_0.png" src="../_images/ml_intro_77_0.png" />
</div>
</div>
</section>
<section id="activation-functions">
<h3>Activation functions<a class="headerlink" href="#activation-functions" title="Permalink to this headline">#</a></h3>
<p>An essential element of neural networks are the activation functions applied to the weighted sum at each neuron. There are a few heuristic criteria for suitable activation function:</p>
<ul class="simple">
<li><p>nonlinear</p></li>
<li><p>continuous with infinite support</p></li>
<li><p>monotonic</p></li>
<li><p>constant slope</p></li>
<li><p>effectively computable</p></li>
</ul>
<p>There is no single activation function suiting all of the above requirements at once. The activation functions of hidden layers should be always nonlinear, because otherwise, the fully connected layers could be condensed into a single layers. Only the output layer might employ an identity activation, e.g., for regression problems. For classification, there are specialized activation functions converting the input into a probability or the logarithm thereof. The most common activation functions for hidden layers are depicted below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>activations = {
    &quot;sigmoid&quot; : pt.nn.Sigmoid,
    &quot;tanh&quot; : pt.nn.Tanh,
    &quot;ReLU&quot; : pt.nn.ReLU,
    &quot;ELU&quot; : pt.nn.ELU,
    &quot;SELU&quot; : pt.nn.SELU
}

x = pt.arange(-3, 3.01, 0.1)
marker = [&quot;v&quot;, &quot;^&quot;, &quot;o&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;]
ls = [&quot;-&quot;, &quot;-&quot;, &quot;--&quot;, &quot;-.&quot;, &quot;-&quot;]
for i, (name, func) in enumerate(activations.items()):
    plt.plot(x, func()(x), ls=ls[i],  marker=marker[i], markevery=10, label=name)
plt.xlim(-3,3)
plt.xlabel(r&quot;$z$&quot;)
plt.ylabel(r&quot;$a(z)$&quot;)
plt.grid(True, ls=&quot;--&quot;)
plt.legend()
plt.savefig(f&quot;{output}/activation_functions.svg&quot;, bbox_inches=&quot;tight&quot;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/ml_intro_79_0.png" src="../_images/ml_intro_79_0.png" />
</div>
</div>
<p>For many problems, the rectified linear unit (ReLU) leads to fast and accurate models. In general, it is fair to say that training with exponential linear units (ELU), scaled exponential linear units (SELU), and ReLU converges significantly faster than with sigmoid. For a mathematical definition of these function, refer to <a class="reference external" href="https://en.wikipedia.org/wiki/Activation_function">this article</a>. On the other hand, functions with higher smoothness also lead to models with higher smoothness. Models employing ReLU may have kinks and non-constant derivatives. However, ReLUs are also significantly faster to compute since they do not contain the exponential function. The experiment below compares the time needed to evaluate several different activation functions. The hyperbolic tangents function takes the most time to be evaluated.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>arg = pt.linspace(-10, 10, 10000)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%timeit -n 10000 -r 10 pt.sigmoid(arg) 
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>13.5 µs ± 192 ns per loop (mean ± std. dev. of 10 runs, 10,000 loops each)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%timeit -n 10000 -r 10 pt.tanh(arg)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>28.8 µs ± 301 ns per loop (mean ± std. dev. of 10 runs, 10,000 loops each)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%timeit -n 10000 -r 10 pt.nn.functional.elu(arg)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>13.5 µs ± 69.7 ns per loop (mean ± std. dev. of 10 runs, 10,000 loops each)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%timeit -n 10000 -r 10 pt.nn.functional.relu(arg)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>5.34 µs ± 86.7 ns per loop (mean ± std. dev. of 10 runs, 10,000 loops each)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%timeit -n 10000 -r 10 pt.nn.functional.selu(arg)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>13.1 µs ± 278 ns per loop (mean ± std. dev. of 10 runs, 10,000 loops each)
</pre></div>
</div>
</div>
</div>
<p>You might be wondering, if the difference of a few micro seconds really matters. Recall that we have to evaluate the activation function for each neuron. Networks may have a few thousand or several billion neurons.  Moreover, we have to evaluate all neurons for each data point during a forward pass. Therefore, similar statistics as the ones above may be found for the overall training time (assuming a constant number of optimization loops).</p>
<p>Another important attribute of an activation function is its derivative with respect to the input. The main reason for the effectiveness of ELU/ReLU/SELU is their constant slope for positive inputs. The constant slope mitigates the problem of vanishing or exploding gradients during the training. For very large networks, it might happen that many neurons employing ReLU become inactive during the training because the slope becomes zero once the input becomes negative. To provide the chance for such neurons to recover, ELU and similar variants were invented. ELU has a small but non-vanishing slope for negative inputs. The reason why training with sigmoid or hyperbolic tangents is usually more difficult lies in their vanishing sensitivity for very large or small arguments. For a long time, this insensitivity made it practically impossible to train networks with many hidden layers because there was no way to control the range of the neurons inputs in the hidden layers. The effect is similar to training with unscaled data. In recent years, a technique called <a class="reference external" href="https://arxiv.org/abs/1502.03167">batch normalization</a> was developed to mitigate the shift of the transformed features in the hidden layers. The SELU function has a similar effect as batch normalization but requires no additional weights.</p>
<p>As a side note, training approaches like PINNs require the computation of higher-order derivatives. Therefore, sigmoid or hyperbolic tangents and all the associated drawbacks are basically the only option.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>x = pt.arange(-3, 3.01, 0.01, requires_grad=True)
marker = [&quot;v&quot;, &quot;^&quot;, &quot;o&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;]
ls = [&quot;-&quot;, &quot;-&quot;, &quot;--&quot;, &quot;-.&quot;, &quot;-&quot;]
cont = [True, True, False, True, False]
color = [&quot;C{:1d}&quot;.format(i) for i in range(len(activations))]
for i, (name, func) in enumerate(activations.items()):
    res = func()(x)
    res.backward(pt.ones(x.shape[0]))
    x_num = x.detach().numpy()
    grad_num =  x.grad.numpy()
    if cont[i]:
        plt.plot(x_num, grad_num,
            ls=ls[i], lw=2, marker=marker[i], markevery=100, color=color[i], label=name)
    else:
        plt.plot([xi for xi in x_num if xi &lt;= 0.0], [dx for xi, dx in zip(x_num, grad_num) if xi &lt;= 0.0],
                ls=ls[i], marker=marker[i], markevery=100, color=color[i], label=name)
        plt.plot([xi for xi in x_num if xi &gt; 0.0], [dx for xi, dx in zip(x_num, grad_num) if xi &gt; 0.0],
                ls=ls[i], marker=marker[i], color=color[i], markevery=100)
    x.grad.data.zero_()
    
plt.xlim(-3,3)
plt.xlabel(r&quot;$z$&quot;)
plt.ylabel(r&quot;$\mathrm{d}_za(z)$&quot;)
plt.grid(True, ls=&quot;--&quot;)
plt.legend()
plt.savefig(f&quot;{output}/activation_slopes.svg&quot;, bbox_inches=&quot;tight&quot;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/ml_intro_88_0.png" src="../_images/ml_intro_88_0.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>results_act = {}
models_act = {}
train_loader = pt.utils.data.DataLoader(train_dataset, batch_size=128, shuffle=True)

for key, act in activations.items():
    model = create_simple_network(2, 1, 50, 2, act)
    optimizer = optimizer=pt.optim.AdamW(model.parameters(), lr=0.01)
    scheduler = pt.optim.lr_scheduler.ReduceLROnPlateau(optimizer=optimizer, mode=&quot;min&quot;, factor=0.5, patience=20, min_lr=1.0e-4)
    results_act[key] = train_model(
        model,
        pt.nn.MSELoss(),
        train_loader, val_loader, test_loader,
        epochs=500,
        lr_schedule=scheduler,
        optimizer=optimizer
    )
    models_act[key] = deepcopy(model)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> Epoch  499/499 - Training loss: 5.979562e-05; Validation loss: 5.140446e-05; Test loss: 7.680662e-05
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig, (ax1, ax2) = plt.subplots(2, figsize=(6, 4), sharex=True, sharey=True)
for i, (key, res) in enumerate(results_act.items()):
    ax1.plot(res[&quot;epoch&quot;], res[&quot;train_loss&quot;], lw=1, label=f&quot;{key}&quot;)
    ax2.plot(res[&quot;epoch&quot;], res[&quot;val_loss&quot;], lw=1, label=f&quot;{key}&quot;)

ax1.set_title(&quot;training&quot;)
ax2.set_title(&quot;validation&quot;)
ax2.set_xlabel(&quot;epoch&quot;)
for ax in (ax1, ax2):
    ax.set_ylabel(&quot;MSE&quot;)
    ax.set_yscale(&quot;log&quot;)
ax1.set_xlim(0, 500)
ax1.legend(ncol=3)
plt.savefig(join(output, &quot;activations_plateau_bs128_lecture_4.svg&quot;), bbox_inches=&quot;tight&quot;)
plt.show()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/ml_intro_90_0.png" src="../_images/ml_intro_90_0.png" />
</div>
</div>
<p>The plot below shows the model employing hyperbolic tangents activations. The accuracy is improved even further. Moreover, all profiles are significantly smoother.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>model = models_act[&quot;tanh&quot;]
pred_train = make_prediction(model, train_tensor[:, 1:], feature_scaler, label_scaler)
pred_val = make_prediction(model, val_tensor[:, 1:], feature_scaler, label_scaler)
pred_test = make_prediction(model, test_tensor[:, 1:], feature_scaler, label_scaler)


n_points = len(y)
for i in range(len(Re)):
    plt.plot(u_x[:, i]/Ubar.max(), y/(2*delta), ls=&quot;-&quot;, c=&quot;k&quot;)
plt.scatter(pred_train, train_tensor[:, 1], s=1, c=&quot;C0&quot;, zorder=6, label=&quot;training&quot;)
plt.scatter(pred_val, val_tensor[:, 1], s=1, c=&quot;C1&quot;, zorder=6, label=&quot;validation&quot;)
plt.scatter(pred_test, test_tensor[:, 1], s=1, c=&quot;C2&quot;, zorder=6, label=&quot;testing&quot;)
plt.xlabel(r&quot;$\tilde{u}_x$&quot;)
plt.ylabel(r&quot;$\tilde{y}$&quot;)
plt.xlim(0.0, 1.2)
plt.ylim(-0.01, 0.5)
plt.legend()
plt.savefig(join(output, &quot;prediction_act_lecture_4.svg&quot;), bbox_inches=&quot;tight&quot;)
plt.show()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/ml_intro_92_0.png" src="../_images/ml_intro_92_0.png" />
</div>
</div>
</section>
<section id="advanced-building-blocks">
<h3>Advanced building blocks<a class="headerlink" href="#advanced-building-blocks" title="Permalink to this headline">#</a></h3>
<p>In the next cells, we test a few advanced network building blocks, namely:</p>
<ul class="simple">
<li><p>normalization: normalization layers aim to improve learning by re-scaling the output of the precessing layer; batch normalization learns normalization across batches, while layer normalization learns normalizing the neuron output within a layer</p></li>
<li><p>skip connections: skipping connections means that the input of an early layer in the network is also provided to layer following later, thereby skipping one or more layers in-between; the inputs are merged by concatenation</p></li>
<li><p>residual blocks: similar to skip connections, residual blocks merge the input of a layer with its output; however, the input for the next layer is created by addition instead of concatenation</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def create_normalized_network(n_in: int, n_out: int, n_neurons: int,
    n_hidden: int, activation: pt.nn.Module, layer_norm: bool = False
    ) -&gt; pt.nn.Sequential:
    if layer_norm:
        norm_layer, norm_size = pt.nn.LayerNorm, [n_neurons]
    else:
        norm_layer, norm_size = pt.nn.BatchNorm1d, n_neurons
    layers = [
        pt.nn.Linear(n_in, n_neurons),
        activation(),
        norm_layer(norm_size)
    ]
    for _ in range(n_hidden):
        layers.append(pt.nn.Linear(n_neurons, n_neurons))
        layers.append(activation())
        layers.append(norm_layer(norm_size))
    layers.append(pt.nn.Linear(n_neurons, n_out))
    return pt.nn.Sequential(*layers)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>class SkipBlock(pt.nn.Module):
    def __init__(self, n_in: int, n_out: int, activation: pt.nn.Module = pt.nn.Tanh,
                 norm: str = None):
        super(SkipBlock, self).__init__()
        self._layer_1 = pt.nn.Linear(n_in, n_in)
        self._layer_2 = pt.nn.Linear(2*n_in, n_out)
        if norm == &quot;batch&quot;:
            self._norm_1 = pt.nn.BatchNorm1d(n_in)
            self._norm_2 = pt.nn.BatchNorm1d(n_out)
        elif norm == &quot;layer&quot;:
            self._norm_1 = pt.nn.LayerNorm([n_in])
            self._norm_2 = pt.nn.LayerNorm([n_out])
        else:
            self._norm_1 = pt.nn.Identity()
            self._norm_2 = pt.nn.Identity()
        self._activation = activation()

    def forward(self, x):
        h = self._norm_1(self._activation(self._layer_1(x)))
        x = pt.cat([x, h], dim=1)
        return self._norm_2(self._activation(self._layer_2(x)))
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def create_skip_network(n_in: int, n_out: int, n_neurons: int, n_hidden: int,
                       activation: pt.nn.Module, norm: str = None) -&gt; pt.nn.Sequential:
    layers = [
        SkipBlock(n_in, n_neurons, activation, norm)
    ]
    for _ in range(n_hidden):
        layers.append(SkipBlock(n_neurons, n_neurons, activation, norm))
    layers.append(pt.nn.Linear(n_neurons, n_out))
    return pt.nn.Sequential(*layers)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>class ResidualBlock(pt.nn.Module):
    def __init__(self, n_in: int, n_out: int, activation: pt.nn.Module, norm: str = None):
        super().__init__()
        layers = [pt.nn.Linear(n_in, n_out)]
        layers.append(activation())
        if norm == &quot;batch&quot;:
            layers.append(pt.nn.BatchNorm1d(n_out))
        elif norm == &quot;layer&quot;:
            layers.append(pt.nn.LayerNorm([n_out]))
        self.F = pt.nn.Sequential(*layers)

    def forward(self, x):
        return x + self.F(x)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def create_res_network(n_in: int, n_out: int, n_neurons: int, n_hidden: int,
                       activation: pt.nn.Module, norm: str = None) -&gt; pt.nn.Sequential:
    layers = [
        pt.nn.Linear(n_in, n_neurons),
        activation()
    ]
    for _ in range(n_hidden):
        layers.append(ResidualBlock(n_neurons, n_neurons, activation, norm))
    layers.append(pt.nn.Linear(n_neurons, n_out))
    return pt.nn.Sequential(*layers)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def generate_advanced_models():
    return {
        &quot;ref.&quot; : create_simple_network(2, 1, 50, 2, pt.nn.Tanh),
        &quot;batch norm.&quot; : create_normalized_network(2, 1, 50, 2, pt.nn.Tanh, False),
        &quot;layer norm.&quot; : create_normalized_network(2, 1, 50, 2, pt.nn.Tanh, True),
        &quot;skip conn.&quot; : create_skip_network(2, 1, 50, 2, pt.nn.Tanh, None),
        &quot;skip conn., layer norm.&quot; : create_skip_network(2, 1, 50, 2, pt.nn.Tanh, &quot;layer&quot;),
        &quot;res. block&quot; : create_res_network(2, 1, 50, 2, pt.nn.Tanh, None),
        &quot;res. block, layer norm.&quot; : create_res_network(2, 1, 50, 2, pt.nn.Tanh, &quot;layer&quot;)
    }
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>results_adv = {}
train_loader = pt.utils.data.DataLoader(train_dataset, batch_size=128, shuffle=True)
for key, model in generate_advanced_models().items():
    optimizer = optimizer=pt.optim.AdamW(model.parameters(), lr=0.01)
    scheduler = pt.optim.lr_scheduler.ReduceLROnPlateau(optimizer=optimizer, mode=&quot;min&quot;, factor=0.5, patience=20, min_lr=1.0e-4)
    results_adv[key] =  train_model(model, pt.nn.MSELoss(), train_loader, val_loader, test_loader,
                                    epochs=500, lr_schedule=scheduler, optimizer=optimizer)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> Epoch  499/499 - Training loss: 5.116301e-05; Validation loss: 2.753079e-05; Test loss: 5.703035e-05
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>for key, res in results_adv.items():
    plt.plot(res[&quot;epoch&quot;], res[&quot;val_loss&quot;], lw=1, label=key)

plt.title(&quot;Validation loss&quot;)
plt.xlabel(&quot;epoch&quot;)
plt.ylabel(&quot;MSE&quot;)
plt.yscale(&quot;log&quot;)
plt.xlim(0, 500)
plt.legend(ncol=3, fontsize=8)
plt.savefig(join(output, &quot;adv_networks_lecture_4.svg&quot;), bbox_inches=&quot;tight&quot;)
plt.show()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/ml_intro_101_0.png" src="../_images/ml_intro_101_0.png" />
</div>
</div>
</section>
<section id="dealing-with-uncertainty">
<h3>Dealing with uncertainty<a class="headerlink" href="#dealing-with-uncertainty" title="Permalink to this headline">#</a></h3>
<p>The training of neural networks is not deterministic. If you go back to any cell in which the model training was performed and execute the cell several times, every time you will end up with a different model and a different loss behavior. The reason for this observation is twofold:</p>
<ol class="simple">
<li><p>the loss function is non-convex</p></li>
<li><p>the initial network parameters are sampled randomly</p></li>
</ol>
<p>Basically, we end up in different local minima in each training run. Fortunately, the situation is not as bad as it seems, because neural networks tend to have many local minima yielding good models. Nonetheless, if we want to rigorously compare two different neural networks, we have to deal with the uncertainty of the training as we would it in a real experiment. We repeat the training several times and compare different models on a statistical basis, e.g., by comparing mean, median, or standard deviation over all runs. In the example below, we compare several network designs based on the best <span class="math notranslate nohighlight">\(L_2\)</span> loss. To keep the training time reasonable each training is repeated ten times.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>n_repeat = 10
results_repeat = defaultdict(list)
for i in range(n_repeat):
    pt.manual_seed(i)
    for key, model in generate_advanced_models().items():
        optimizer = optimizer=pt.optim.AdamW(model.parameters(), lr=0.01)
        scheduler = pt.optim.lr_scheduler.ReduceLROnPlateau(optimizer=optimizer, mode=&quot;min&quot;, factor=0.5, patience=20, min_lr=1.0e-4)
        results_repeat[key].append(train_model(model, pt.nn.MSELoss(), train_loader, val_loader, test_loader,
                                   epochs=500, lr_schedule=scheduler, optimizer=optimizer))
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> Epoch  499/499 - Training loss: 5.767075e-05; Validation loss: 6.188699e-05; Test loss: 3.591628e-05
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>for i, key in enumerate(results_repeat.keys()):
    test_loss = np.asarray(
        [res[&quot;test_loss&quot;].values[-10:].mean() for res in results_repeat[key]]
    )
    plt.boxplot(test_loss, positions=[i], flierprops={
                &quot;markersize&quot;: 6, &quot;markeredgecolor&quot;: &quot;C3&quot;})
plt.gca().set_xticklabels((&quot;ref.&quot;, &quot;batch\nnorm.&quot;, &quot;layer\nnorm.&quot;, &quot;skip\nconn.&quot;, &quot;skip+ln&quot;, &quot;res.\nblock&quot;, &quot;res+ln&quot;))
plt.yscale(&quot;log&quot;)
plt.ylabel(&quot;MSE (test)&quot;)
plt.grid(ls=&quot;--&quot;)
plt.savefig(join(output, &quot;uncertainty_arch_lecture_4.svg&quot;), bbox_inches=&quot;tight&quot;)
plt.show()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/ml_intro_104_0.png" src="../_images/ml_intro_104_0.png" />
</div>
</div>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Box_plot">Box plots</a> present a very rich visualization of groups of data. In the figure above, we compare the box plots resulting from the different network architectures. Box plots mainly work with quantiles. The <span class="math notranslate nohighlight">\(p\)</span>th quantile, denoted by <span class="math notranslate nohighlight">\(q_p\)</span>, is obtained by sorting the data and then counting through the data until <span class="math notranslate nohighlight">\(p\%\)</span> of the overall number of data points are reached. For example, the <span class="math notranslate nohighlight">\(50\)</span> th quantile of the set <span class="math notranslate nohighlight">\(\{ 3, 1, 5, 4, 2\}\)</span> would be <span class="math notranslate nohighlight">\(q_{50} = 2\)</span>. The <span class="math notranslate nohighlight">\(50\%\)</span> quantile is commonly called median. In a box plot, the lower and upper boundaries of the box are given by the <span class="math notranslate nohighlight">\(25\)</span>th and <span class="math notranslate nohighlight">\(75\)</span>th quantiles, respectively. The orange line in the plot below indicates the median. Quantiles are also used to identify outliers. The inter quantile range (IQR) is defined as <span class="math notranslate nohighlight">\(q_r = q_{75} - q_{25}\)</span>. Outlier detection based on the IQR assumes that values in the range <span class="math notranslate nohighlight">\(q_{25}-kq_r \le x \le q_{75}+kq_r\)</span> are regular values, whereas values outside this range are outliers. The factor <span class="math notranslate nohighlight">\(k\)</span> is often chosen as <span class="math notranslate nohighlight">\(k=1.5\)</span>. Outliers in the plot below are indicated by red circles. The so-called whiskers (the little antennas extending from the box) indicate the largest and smallest values not considered to be outliers. From box plots, we can infer the spread of the data and also how it is distributed. For example, if the whiskers are symmetric and the median is in the middle of the box, the data are normally distributed (approximately).</p>
<p>In ML research, we want our experiments to be repeatable, even if random sampling is part of the process. Luckily, there are no true random numbers in computer programs. Instead, they are said to be <em>pseudo random</em>, because we can define a so-called <em>seed</em> parameter that makes the sampling repeatable. In the loop of the code cell above, we use the loop count as seed. Therefore, the initial weights change for each training run in a repeatable manner.</p>
<p>An important design parameter to change the model’s flexibility (the ability to fit data) is the number of hidden layers. In the code cell below, we conduct a similar experiment as before but vary only the number of hidden layers. As can be seen in the box plots, the loss and also the spread of the loss decreases significantly as the number of hidden layers increases. Moreover, the improvement in the <span class="math notranslate nohighlight">\(L_2\)</span> loss seems to become smaller and smaller with each additional hidden layers.</p>
</section>
<section id="visualizing-prediction-errors">
<h3>Visualizing prediction errors<a class="headerlink" href="#visualizing-prediction-errors" title="Permalink to this headline">#</a></h3>
<p>As mentioned before, it is relatively easy to assess the model’s behavior for the present problem. For high-dimensional parameter spaces, the evaluation is less straightforward, and we have to rely on statistics and other less intuitive means of visualization. Two techniques are demonstrated below:</p>
<ul class="simple">
<li><p>a histogram of the prediction error; the histogram shows how the error is distributed; ideally, all prediction errors should be located in a narrow band around zero; we can immediately read the maximum prediction errors and infer how many predictions yield such high errors</p></li>
<li><p>a heatmap with the maximum prediction errors in different sub-sections of the feature space; if we had more features, we would create the same plot for the two most important features, or we would create several heatmaps for different combinations of features; the heatmap indicates which sections of the feature space yield high prediction errors; in the example below we see that prediction errors are high for small distances and large Reynolds numbers</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>final_model = create_skip_network(2, 1, 50, 2, pt.nn.Tanh)
optimizer = optimizer=pt.optim.AdamW(final_model.parameters(), lr=1.0e-2)
scheduler = pt.optim.lr_scheduler.ReduceLROnPlateau(optimizer=optimizer, mode=&quot;min&quot;, factor=0.5, patience=20, min_lr=1.0e-4)
final_results = train_model(final_model, pt.nn.MSELoss(), train_loader, val_loader, test_loader,
                            epochs=500, lr_schedule=scheduler, optimizer=optimizer)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> Epoch  499/499 - Training loss: 8.186048e-06; Validation loss: 6.622953e-06; Test loss: 7.083297e-06
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>pred_train_final = make_prediction(final_model, train_tensor[:, 1:], feature_scaler, label_scaler)
pred_val_final = make_prediction(final_model, val_tensor[:, 1:], feature_scaler, label_scaler)
pred_test_final = make_prediction(final_model, test_tensor[:, 1:], feature_scaler, label_scaler)


n_points = len(y)
for i in range(len(Re)):
    plt.plot(u_x[:, i]/Ubar.max(), y/(2*delta), ls=&quot;-&quot;, c=&quot;k&quot;)
plt.scatter(pred_train_final, train_tensor[:, 1], s=1, c=&quot;C0&quot;, zorder=6, label=&quot;training&quot;)
plt.scatter(pred_val_final, val_tensor[:, 1], s=1, c=&quot;C1&quot;, zorder=6, label=&quot;validation&quot;)
plt.scatter(pred_test_final, test_tensor[:, 1], s=1, c=&quot;C2&quot;, zorder=6, label=&quot;testing&quot;)
plt.xlabel(r&quot;$\tilde{u}_x$&quot;)
plt.ylabel(r&quot;$\tilde{y}$&quot;)
plt.xlim(0.0, 1.2)
plt.ylim(-0.01, 0.5)
plt.legend()
plt.savefig(join(output, &quot;final_prediction_lecture_4_model_pl.svg&quot;), bbox_inches=&quot;tight&quot;)
plt.show()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/ml_intro_109_0.png" src="../_images/ml_intro_109_0.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>deviation = pred_train_final - train_tensor[:, 0]
dev_min, dev_max = deviation.min().item(), deviation.max().item()
counts = pt.histc(deviation, bins=50, min=dev_min, max=dev_max).detach()
bin_width = (dev_max-dev_min) / 50
centers = pt.arange(dev_min+0.5*bin_width, dev_min +
                    50*bin_width, bin_width).detach()

plt.bar(centers, counts, width=bin_width*0.8)
plt.xlabel(r&quot;$\hat{\tilde{u}}_x - \tilde{u}_{x}$&quot;)
plt.ylabel(&quot;bin count&quot;)
plt.savefig(f&quot;{output}/profile_error_hist.svg&quot;, bbox_inches=&quot;tight&quot;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/ml_intro_110_0.png" src="../_images/ml_intro_110_0.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def max_error_map(x: pt.Tensor, err: pt.Tensor, bins: int) -&gt; pt.Tensor:
    &quot;&quot;&quot;Divide feature space in bins and compute maximum error for each bin.

    :param x: feature tensor
    :type x: pt.Tensor
    :param err: absolute error values
    :type err: pt.Tensor
    :param bins: number of bin
    :type bins: int
    :return: 2D tensor with maximum errors for each bin; if there are N bins,
        the result will be a NxN tensor
    :rtype: pt.Tensor
    &quot;&quot;&quot;
    step = 2.0 / bins
    bounds_low = pt.arange(-1, 1.0, step)
    bounds_up = pt.arange(-1+step, 1.0+0.5*step, step)
    max_error = pt.zeros((bins, bins))
    for i, (low_i, up_i) in enumerate(zip(bounds_low, bounds_up)):
        for j, (low_j, up_j) in enumerate(zip(bounds_low, bounds_up)):
            errors = pt.where((x[:, 0] &gt;= low_i) &amp; (x[:, 1] &gt;= low_j) &amp; (
                x[:, 0] &lt; up_i) &amp; (x[:, 1] &lt; up_j), err.type(pt.float64), 0.0)
            max_error[i, j] = errors.max()
    return max_error


error_map = max_error_map(feature_scaler.scale(train_tensor[:, 1:]), deviation.abs(), 10)
edges = pt.linspace(-1, 1, 10+1)
xx, yy = pt.meshgrid(edges, edges, indexing=&quot;ij&quot;)
pcol = plt.pcolormesh(xx.detach(), yy.detach(), error_map.detach())
plt.colorbar(pcol, label=r&quot;$|\hat{\tilde{u}}_x - \tilde{u}_{x}|$&quot;)
plt.xlabel(r&quot;$\tilde{y}_{norm}$&quot;)
plt.ylabel(r&quot;$Re_{norm}$&quot;)
plt.savefig(join(output, &quot;profile_error_heatmap.svg&quot;), bbox_inches=&quot;tight&quot;)
plt.show()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/ml_intro_111_0.png" src="../_images/ml_intro_111_0.png" />
</div>
</div>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./notebooks"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="cfd_intro.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Finite-volume-based CFD in a nutshell</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="bubble_path_classification.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Predicting the stability regime of rising bubbles</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By AndreWeiner, converted by thangckt<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>